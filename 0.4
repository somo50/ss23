import os
import json
import csv
import tkinter as tk
from tkinter import font as tkfont, filedialog, messagebox, ttk
from datetime import datetime
from pathlib import Path
import customtkinter as ctk
import numpy as np
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font, Alignment
from tabulate import tabulate
from PIL import Image, ImageDraw, ImageFont, ImageTk
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib.colors import HexColor
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import Paragraph, Frame, KeepInFrame, Table, TableStyle, Image as RLImage, PageBreak, SimpleDocTemplate
from reportlab.lib.enums import TA_RIGHT, TA_CENTER, TA_LEFT
from reportlab.lib import colors
import arabic_reshaper
from bidi.algorithm import get_display
import tempfile
import shutil
import configparser
import sqlite3
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib
matplotlib.use('TkAgg')
# --------------------------------------------------
APP_DIR    = Path(__file__).parent
MEMORY_DIR = APP_DIR / "memory"
MEMORY_DIR.mkdir(exist_ok=True)
MEMORY_FILE   = MEMORY_DIR / "memory.json"
SETTINGS_FILE = APP_DIR / "settings.json"
FONTS_DIR = APP_DIR / "fonts"
FONTS_DIR.mkdir(exist_ok=True)
DB_CONFIG_FILE = APP_DIR / "db.ini"
DB_FILE = APP_DIR / "ultra_pipe.db"
# Initialize database if not exists
def init_database():
    if not DB_FILE.exists():
        conn = sqlite3.connect(str(DB_FILE))
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                part_name TEXT NOT NULL,
                diameter TEXT,
                datetime TEXT NOT NULL,
                notes TEXT,
                photo_path TEXT,
                headers TEXT,  -- JSON string
                data TEXT,     -- JSON string
                source_file TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    # Create db.ini if not exists
    if not DB_CONFIG_FILE.exists():
        config = configparser.ConfigParser()
        config['DATABASE'] = {'path': str(DB_FILE)}
        with open(DB_CONFIG_FILE, 'w') as f:
            config.write(f)
init_database()
# Database functions
def get_db_path():
    config = configparser.ConfigParser()
    config.read(DB_CONFIG_FILE)
    return config['DATABASE']['path']
def set_db_path(path):
    config = configparser.ConfigParser()
    config['DATABASE'] = {'path': path}
    with open(DB_CONFIG_FILE, 'w') as f:
        config.write(f)
def create_new_database():
    new_db_path = filedialog.asksaveasfilename(
        defaultextension=".db",
        filetypes=[("Database files", "*.db")],
        initialdir=str(APP_DIR)
    )
    if new_db_path:
        conn = sqlite3.connect(new_db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                part_name TEXT NOT NULL,
                diameter TEXT,
                datetime TEXT NOT NULL,
                notes TEXT,
                photo_path TEXT,
                headers TEXT,  -- JSON string
                data TEXT,     -- JSON string
                source_file TEXT
            )
        ''')
        conn.commit()
        conn.close()
        set_db_path(new_db_path)
        return new_db_path
    return None
def insert_record_to_db(record, source_file=None):
    db_path = get_db_path()
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO records (part_name, diameter, datetime, notes, photo_path, headers, data, source_file)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (
        record["meta"]["part_name"],
        record["meta"]["diameter"],
        record["meta"]["datetime"],
        record["meta"]["notes"],
        record["meta"]["photo"],
        json.dumps(record["headers"]),
        json.dumps(record["data"]),
        source_file
    ))
    conn.commit()
    conn.close()
def search_db_records(query=None, filters=None):
    db_path = get_db_path()
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    sql = "SELECT * FROM records"
    params = []
    
    if query or filters:
        conditions = []
        if query:
            conditions.append("(part_name LIKE ? OR notes LIKE ? OR source_file LIKE ?)")
            params.extend([f"%{query}%", f"%{query}%", f"%{query}%"])
        if filters:
            if filters.get('part_name'):
                conditions.append("part_name LIKE ?")
                params.append(f"%{filters['part_name']}%")
            if filters.get('diameter'):
                conditions.append("diameter LIKE ?")
                params.append(f"%{filters['diameter']}%")
            if filters.get('datetime_from'):
                conditions.append("datetime >= ?")
                params.append(filters['datetime_from'])
            if filters.get('datetime_to'):
                conditions.append("datetime <= ?")
                params.append(filters['datetime_to'])
            if filters.get('source_file'):
                conditions.append("source_file LIKE ?")
                params.append(f"%{filters['source_file']}%")
        
        if conditions:
            sql += " WHERE " + " AND ".join(conditions)
    
    sql += " ORDER BY datetime DESC"
    
    cursor.execute(sql, params)
    records = cursor.fetchall()
    conn.close()
    
    # Convert to list of dicts and parse JSON fields
    result = []
    for row in records:
        record = dict(row)
        record['headers'] = json.loads(record['headers'])
        record['data'] = json.loads(record['data'])
        result.append(record)
    
    return result
# Download and register fonts for better Arabic support
def setup_fonts():
    try:
        # Try to register Arial and Times New Roman for PDF generation
        arial_path = FONTS_DIR / "Arial.ttf"
        arial_bold_path = FONTS_DIR / "Arial_Bold.ttf"
        times_path = FONTS_DIR / "Times_New_Roman.ttf"
        times_bold_path = FONTS_DIR / "Times_New_Roman_Bold.ttf"
        
        # Register fonts with ReportLab
        try:
            pdfmetrics.registerFont(TTFont('Arial', str(arial_path)))
            pdfmetrics.registerFont(TTFont('Arial-Bold', str(arial_bold_path)))
        except:
            # Fallback to default fonts
            try:
                pdfmetrics.registerFont(TTFont('Arial', 'arial.ttf'))
                pdfmetrics.registerFont(TTFont('Arial-Bold', 'arialbd.ttf'))
            except:
                # Use Helvetica as fallback
                pdfmetrics.registerFont(TTFont('Arial', 'Helvetica'))
                pdfmetrics.registerFont(TTFont('Arial-Bold', 'Helvetica-Bold'))
            
        try:
            pdfmetrics.registerFont(TTFont('TimesNewRoman', str(times_path)))
            pdfmetrics.registerFont(TTFont('TimesNewRoman-Bold', str(times_bold_path)))
        except:
            # Fallback to default fonts
            try:
                pdfmetrics.registerFont(TTFont('TimesNewRoman', 'times.ttf'))
                pdfmetrics.registerFont(TTFont('TimesNewRoman-Bold', 'timesbd.ttf'))
            except:
                # Use Times-Roman as fallback
                pdfmetrics.registerFont(TTFont('TimesNewRoman', 'Times-Roman'))
                pdfmetrics.registerFont(TTFont('TimesNewRoman-Bold', 'Times-Bold'))
    except Exception as e:
        print(f"Font setup error: {e}")
setup_fonts()
# --------------------------------------------------
def load_json(path, default=None):
    try:
        return json.loads(Path(path).read_text(encoding="utf-8"))
    except Exception:
        return default or {}
def save_json(path, data):
    Path(path).write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
settings = load_json(
    SETTINGS_FILE,
    dict(
        rtv_eq="thme - (2.331 * coth * 0.001)",
        cr_eq="old_real_thickness - RTV",  # CR = old - RTV (كما طلبت)
        theme="dark-blue",
        last_excel="",
        monospace=True,
        pdf_settings={
            "station_name": "Ultra-Pipe Inspection",
            "spacing": 2,
            "font_family": "Arial",
            "font_size": 10,
            "watermark_path": "",
            "watermark_size": 30,
            "watermark_opacity": 0.2,
            "page_orientation": "portrait",
            "margin_top": 1.0,
            "margin_bottom": 1.0,
            "margin_left": 1.0,
            "margin_right": 1.0,
            "include_interface": True,
            "include_notes_at_end": True,
            "interface_title": "Interface Screenshot",
            "notes_title": "Notes and Images",
            "header_font_size": 14,
            "table_font_size": 10,
            "notes_font_size": 10,
            "table_border_color": "#000000",
            "table_header_color": "#cccccc",
            "table_row_color": "#f0f0f0",
        }
    ),
)
THEMES = {
    "dark-blue": {"bg": "#2b2b2b", "entry": "#3f3f3f", "text": "#ffffff"},
    "dark-green": {"bg": "#1e1e1e", "entry": "#2e2e2e", "text": "#ffffff"},
    "sweet-red": {"bg": "#3a1c1c", "entry": "#4f2a2a", "text": "#ffffff"},
    "purple": {"bg": "#2a1a2a", "entry": "#3c2a3c", "text": "#ffffff"},
    "ocean": {"bg": "#e0f7fa", "entry": "#b2ebf2", "text": "#000000"},
    "mint": {"bg": "#e8f5e9", "entry": "#c8e6c9", "text": "#000000"},
    "rose": {"bg": "#fce4ec", "entry": "#f8bbd0", "text": "#000000"},
    "lavender": {"bg": "#f3e5f5", "entry": "#e1bee7", "text": "#000000"},
    "midnight": {"bg": "#121212", "entry": "#1e1e1e", "text": "#ffffff"},
    "sunset": {"bg": "#3e2723", "entry": "#5d4037", "text": "#ffffff"},
}
# --------------------------------------------------
def safe_eval(eq, **kw):
    try:
        return eval(eq, {"__builtins__": {}}, kw)
    except Exception as e:
        messagebox.showerror("Equation Error", str(e))
        return None
# Helpers ----------------------------------------------------
def parse_values(s: str):
    """Accept separators: space, comma, pipe. Return list[float]."""
    for ch in ["|", ",", "\n", "\t"]:
        s = s.replace(ch, " ")
    parts = [p for p in s.split() if p]
    return list(map(float, parts))
def count_values(s: str) -> int:
    try:
        return len(parse_values(s))
    except Exception:
        # If not parsable yet, count tentative tokens (split by separators)
        for ch in ["|", ",", "\n", "\t"]:
            s = s.replace(ch, " ")
        return len([p for p in s.split() if p])
        
# Arabic text handling
def process_arabic_text(text):
    """Process Arabic text to display correctly"""
    if not text:
        return text
    try:
        # Check if arabic_reshaper and bidi are available
        if 'arabic_reshaper' in globals() and 'get_display' in globals():
            try:
                reshaped_text = arabic_reshaper.reshape(text)
                return get_display(reshaped_text)
            except Exception as e:
                print(f"Arabic reshaping error: {e}")
                return text
        else:
            return text
    except Exception as e:
        print(f"Arabic text processing error: {e}")
        return text
# --------------------------------------------------
class PDFExportDialog(ctk.CTkToplevel):
    def __init__(self, parent, records, colors, excel_data=None):
        super().__init__(parent)
        self.title("PDF Export Settings")
        self.geometry("1400x900")  # Larger size
        self.resizable(True, True)  # Make resizable
        self.records = records
        self.colors = colors  # Store the colors
        self.excel_data = excel_data or []  # Store Excel data
        self.pdf_settings = settings.get("pdf_settings", {})
        self.preview_image = None
        self.preview_photo = None  # For tkinter PhotoImage
        
        # Make dialog appear on top
        self.transient(parent)
        self.grab_set()
        
        # Configure grid weights
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        # Create main frames
        self.settings_frame = ctk.CTkFrame(self, fg_color=self.colors["bg"])
        self.settings_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        
        self.preview_frame = ctk.CTkFrame(self, fg_color=self.colors["bg"])
        self.preview_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        
        self.buttons_frame = ctk.CTkFrame(self, fg_color=self.colors["bg"])
        self.buttons_frame.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky="ew")
        
        # Create notebook for settings tabs
        self.notebook = ctk.CTkTabview(self.settings_frame, fg_color=self.colors["bg"])
        self.notebook.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Create tabs
        self.notebook.add("Basic")
        self.notebook.add("Advanced")
        self.notebook.add("Layout")
        self.notebook.add("Styling")
        self.notebook.add("Interface")
        
        # Build tab contents
        self.create_basic_tab()
        self.create_advanced_tab()
        self.create_layout_tab()
        self.create_styling_tab()
        self.create_interface_tab()
        
        self.create_preview_ui()
        self.create_buttons()
        
        # Initial preview
        self.update_preview()
        
    def create_basic_tab(self):
        tab = self.notebook.tab("Basic")
        tab.configure(fg_color=self.colors["bg"])
        
        # Station Name
        ctk.CTkLabel(tab, text="Station Name:", text_color=self.colors["text"]).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.station_name_var = ctk.StringVar(value=self.pdf_settings.get("station_name", "Ultra-Pipe Inspection"))
        self.station_name_entry = ctk.CTkEntry(tab, textvariable=self.station_name_var, width=200, 
                                              fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.station_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        self.station_name_entry.bind("<KeyRelease>", lambda e: self.update_preview())
        
        # Spacing
        ctk.CTkLabel(tab, text="Spacing (1-4):", text_color=self.colors["text"]).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.spacing_var = ctk.IntVar(value=self.pdf_settings.get("spacing", 2))
        self.spacing_slider = ctk.CTkSlider(tab, from_=1, to=4, variable=self.spacing_var, 
                                          number_of_steps=3, width=200)
        self.spacing_slider.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        self.spacing_slider.bind("<ButtonRelease-1>", lambda e: self.update_preview())
        
        # Font Family
        ctk.CTkLabel(tab, text="Font Family:", text_color=self.colors["text"]).grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.font_family_var = ctk.StringVar(value=self.pdf_settings.get("font_family", "Arial"))
        self.font_family_combo = ctk.CTkComboBox(tab, variable=self.font_family_var, 
                                                values=["Arial", "Times New Roman", "Courier New", "Helvetica"],
                                                width=200, fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.font_family_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        self.font_family_combo.bind("<<ComboboxSelected>>", lambda e: self.update_preview())
        
        # Font Size
        ctk.CTkLabel(tab, text="Font Size:", text_color=self.colors["text"]).grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.font_size_var = ctk.IntVar(value=self.pdf_settings.get("font_size", 10))
        self.font_size_slider = ctk.CTkSlider(tab, from_=8, to=16, variable=self.font_size_var, 
                                            number_of_steps=8, width=200)
        self.font_size_slider.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        self.font_size_slider.bind("<ButtonRelease-1>", lambda e: self.update_preview())
        
        # Watermark
        ctk.CTkLabel(tab, text="Watermark Image:", text_color=self.colors["text"]).grid(row=4, column=0, sticky="w", padx=5, pady=5)
        self.watermark_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        self.watermark_frame.grid(row=4, column=1, sticky="ew", padx=5, pady=5)
        
        self.watermark_path_var = ctk.StringVar(value=self.pdf_settings.get("watermark_path", ""))
        self.watermark_path_entry = ctk.CTkEntry(self.watermark_frame, textvariable=self.watermark_path_var, width=150,
                                                 fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.watermark_path_entry.pack(side="left", padx=5)
        
        self.watermark_browse_btn = ctk.CTkButton(self.watermark_frame, text="Browse", width=60, 
                                                 command=self.browse_watermark)
        self.watermark_browse_btn.pack(side="left", padx=5)
        
        self.watermark_clear_btn = ctk.CTkButton(self.watermark_frame, text="Clear", width=60, 
                                                command=self.clear_watermark)
        self.watermark_clear_btn.pack(side="left", padx=5)
        
        # Watermark Size
        ctk.CTkLabel(tab, text="Watermark Size (%):", text_color=self.colors["text"]).grid(row=5, column=0, sticky="w", padx=5, pady=5)
        self.watermark_size_var = ctk.IntVar(value=self.pdf_settings.get("watermark_size", 30))
        self.watermark_size_slider = ctk.CTkSlider(tab, from_=10, to=100, variable=self.watermark_size_var, 
                                                  width=200)
        self.watermark_size_slider.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
        self.watermark_size_slider.bind("<ButtonRelease-1>", lambda e: self.update_preview())
        
        # Watermark Opacity
        ctk.CTkLabel(tab, text="Watermark Opacity:", text_color=self.colors["text"]).grid(row=6, column=0, sticky="w", padx=5, pady=5)
        self.watermark_opacity_var = ctk.DoubleVar(value=self.pdf_settings.get("watermark_opacity", 0.2))
        self.watermark_opacity_slider = ctk.CTkSlider(tab, from_=0.1, to=1.0, variable=self.watermark_opacity_var, 
                                                     width=200)
        self.watermark_opacity_slider.grid(row=6, column=1, sticky="ew", padx=5, pady=5)
        self.watermark_opacity_slider.bind("<ButtonRelease-1>", lambda e: self.update_preview())
        
        # Configure column weight
        tab.grid_columnconfigure(1, weight=1)
        
    def create_advanced_tab(self):
        tab = self.notebook.tab("Advanced")
        tab.configure(fg_color=self.colors["bg"])
        
        # Page Orientation
        ctk.CTkLabel(tab, text="Page Orientation:", text_color=self.colors["text"]).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.orientation_var = ctk.StringVar(value=self.pdf_settings.get("page_orientation", "portrait"))
        orientation_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        orientation_frame.grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        ctk.CTkRadioButton(orientation_frame, text="Portrait", variable=self.orientation_var, 
                          value="portrait").pack(side="left", padx=5)
        ctk.CTkRadioButton(orientation_frame, text="Landscape", variable=self.orientation_var, 
                          value="landscape").pack(side="left", padx=5)
        
        # Margins
        ctk.CTkLabel(tab, text="Margins (cm):", text_color=self.colors["text"]).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        margins_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        margins_frame.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Top margin
        ctk.CTkLabel(margins_frame, text="Top:", text_color=self.colors["text"]).grid(row=0, column=0, padx=2)
        self.margin_top_var = ctk.DoubleVar(value=self.pdf_settings.get("margin_top", 1.0))
        ctk.CTkEntry(margins_frame, textvariable=self.margin_top_var, width=50,
                    fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=0, column=1, padx=2)
        
        # Bottom margin
        ctk.CTkLabel(margins_frame, text="Bottom:", text_color=self.colors["text"]).grid(row=0, column=2, padx=2)
        self.margin_bottom_var = ctk.DoubleVar(value=self.pdf_settings.get("margin_bottom", 1.0))
        ctk.CTkEntry(margins_frame, textvariable=self.margin_bottom_var, width=50,
                    fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=0, column=3, padx=2)
        
        # Left margin
        ctk.CTkLabel(margins_frame, text="Left:", text_color=self.colors["text"]).grid(row=1, column=0, padx=2)
        self.margin_left_var = ctk.DoubleVar(value=self.pdf_settings.get("margin_left", 1.0))
        ctk.CTkEntry(margins_frame, textvariable=self.margin_left_var, width=50,
                    fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=1, column=1, padx=2)
        
        # Right margin
        ctk.CTkLabel(margins_frame, text="Right:", text_color=self.colors["text"]).grid(row=1, column=2, padx=2)
        self.margin_right_var = ctk.DoubleVar(value=self.pdf_settings.get("margin_right", 1.0))
        ctk.CTkEntry(margins_frame, textvariable=self.margin_right_var, width=50,
                    fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=1, column=3, padx=2)
        
        # Configure column weight
        tab.grid_columnconfigure(1, weight=1)
        
    def create_layout_tab(self):
        tab = self.notebook.tab("Layout")
        tab.configure(fg_color=self.colors["bg"])
        
        # Include Interface
        self.include_interface_var = ctk.BooleanVar(value=self.pdf_settings.get("include_interface", True))
        ctk.CTkCheckBox(tab, text="Include Interface Screenshot", variable=self.include_interface_var,
                       text_color=self.colors["text"]).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        
        # Interface Title
        ctk.CTkLabel(tab, text="Interface Title:", text_color=self.colors["text"]).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.interface_title_var = ctk.StringVar(value=self.pdf_settings.get("interface_title", "Interface Screenshot"))
        self.interface_title_entry = ctk.CTkEntry(tab, textvariable=self.interface_title_var, width=200,
                                                fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.interface_title_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Include Notes at End
        self.include_notes_at_end_var = ctk.BooleanVar(value=self.pdf_settings.get("include_notes_at_end", True))
        ctk.CTkCheckBox(tab, text="Include Notes at End of Report", variable=self.include_notes_at_end_var,
                       text_color=self.colors["text"]).grid(row=2, column=0, sticky="w", padx=5, pady=5)
        
        # Notes Title
        ctk.CTkLabel(tab, text="Notes Section Title:", text_color=self.colors["text"]).grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.notes_title_var = ctk.StringVar(value=self.pdf_settings.get("notes_title", "Notes and Images"))
        self.notes_title_entry = ctk.CTkEntry(tab, textvariable=self.notes_title_var, width=200,
                                             fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.notes_title_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # Configure column weight
        tab.grid_columnconfigure(1, weight=1)
        
    def create_styling_tab(self):
        tab = self.notebook.tab("Styling")
        tab.configure(fg_color=self.colors["bg"])
        
        # Header Font Size
        ctk.CTkLabel(tab, text="Header Font Size:", text_color=self.colors["text"]).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.header_font_size_var = ctk.IntVar(value=self.pdf_settings.get("header_font_size", 14))
        self.header_font_size_slider = ctk.CTkSlider(tab, from_=10, to=20, variable=self.header_font_size_var, 
                                                   number_of_steps=10, width=200)
        self.header_font_size_slider.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Table Font Size
        ctk.CTkLabel(tab, text="Table Font Size:", text_color=self.colors["text"]).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.table_font_size_var = ctk.IntVar(value=self.pdf_settings.get("table_font_size", 10))
        self.table_font_size_slider = ctk.CTkSlider(tab, from_=8, to=16, variable=self.table_font_size_var, 
                                                  number_of_steps=8, width=200)
        self.table_font_size_slider.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Notes Font Size
        ctk.CTkLabel(tab, text="Notes Font Size:", text_color=self.colors["text"]).grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.notes_font_size_var = ctk.IntVar(value=self.pdf_settings.get("notes_font_size", 10))
        self.notes_font_size_slider = ctk.CTkSlider(tab, from_=8, to=16, variable=self.notes_font_size_var, 
                                                   number_of_steps=8, width=200)
        self.notes_font_size_slider.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Table Border Color
        ctk.CTkLabel(tab, text="Table Border Color:", text_color=self.colors["text"]).grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.table_border_color_var = ctk.StringVar(value=self.pdf_settings.get("table_border_color", "#000000"))
        self.table_border_color_entry = ctk.CTkEntry(tab, textvariable=self.table_border_color_var, width=100,
                                                     fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.table_border_color_entry.grid(row=3, column=1, sticky="w", padx=5, pady=5)
        
        # Table Header Color
        ctk.CTkLabel(tab, text="Table Header Color:", text_color=self.colors["text"]).grid(row=4, column=0, sticky="w", padx=5, pady=5)
        self.table_header_color_var = ctk.StringVar(value=self.pdf_settings.get("table_header_color", "#cccccc"))
        self.table_header_color_entry = ctk.CTkEntry(tab, textvariable=self.table_header_color_var, width=100,
                                                     fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.table_header_color_entry.grid(row=4, column=1, sticky="w", padx=5, pady=5)
        
        # Table Row Color
        ctk.CTkLabel(tab, text="Table Row Color:", text_color=self.colors["text"]).grid(row=5, column=0, sticky="w", padx=5, pady=5)
        self.table_row_color_var = ctk.StringVar(value=self.pdf_settings.get("table_row_color", "#f0f0f0"))
        self.table_row_color_entry = ctk.CTkEntry(tab, textvariable=self.table_row_color_var, width=100,
                                                  fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.table_row_color_entry.grid(row=5, column=1, sticky="w", padx=5, pady=5)
        
        # Configure column weight
        tab.grid_columnconfigure(1, weight=1)
        
    def create_interface_tab(self):
        tab = self.notebook.tab("Interface")
        tab.configure(fg_color=self.colors["bg"])
        
        # Interface Customization
        ctk.CTkLabel(tab, text="Interface Customization", text_color=self.colors["text"],
                    font=ctk.CTkFont(size=16, weight="bold")).grid(row=0, column=0, columnspan=2, pady=10)
        
        # Background Color
        ctk.CTkLabel(tab, text="Background Color:", text_color=self.colors["text"]).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.bg_color_var = ctk.StringVar(value=self.colors["bg"])
        bg_color_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        bg_color_frame.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        for color_name, color_value in THEMES.items():
            ctk.CTkRadioButton(bg_color_frame, text=color_name, variable=self.bg_color_var, 
                              value=color_value).pack(side="left", padx=5)
        
        # Text Color
        ctk.CTkLabel(tab, text="Text Color:", text_color=self.colors["text"]).grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.text_color_var = ctk.StringVar(value=self.colors["text"])
        text_color_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        text_color_frame.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        ctk.CTkRadioButton(text_color_frame, text="Light", variable=self.text_color_var, 
                         value="#000000").pack(side="left", padx=5)
        ctk.CTkRadioButton(text_color_frame, text="Dark", variable=self.text_color_var, 
                         value="#ffffff").pack(side="left", padx=5)
        
        # Entry Color
        ctk.CTkLabel(tab, text="Entry Color:", text_color=self.colors["text"]).grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.entry_color_var = ctk.StringVar(value=self.colors["entry"])
        entry_color_frame = ctk.CTkFrame(tab, fg_color=self.colors["bg"])
        entry_color_frame.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        ctk.CTkRadioButton(entry_color_frame, text="Light", variable=self.entry_color_var, 
                         value="#ffffff").pack(side="left", padx=5)
        ctk.CTkRadioButton(entry_color_frame, text="Dark", variable=self.entry_color_var, 
                         value="#2b2b2b").pack(side="left", padx=5)
        ctk.CTkRadioButton(entry_color_frame, text="Medium", variable=self.entry_color_var, 
                         value="#3f3f3f").pack(side="left", padx=5)
        
        # Apply Button
        apply_btn = ctk.CTkButton(tab, text="Apply Interface Settings", command=self.apply_interface_settings)
        apply_btn.grid(row=4, column=0, columnspan=2, pady=10)
        
        # Configure column weight
        tab.grid_columnconfigure(1, weight=1)
        
    def apply_interface_settings(self):
        # Get the selected colors
        bg_color = self.bg_color_var.get()
        text_color = self.text_color_var.get()
        entry_color = self.entry_color_var.get()
        
        # Update the theme
        for theme_name, theme_values in THEMES.items():
            if theme_values["bg"] == bg_color:
                settings["theme"] = theme_name
                break
        
        # Update the interface colors
        self.colors["bg"] = bg_color
        self.colors["text"] = text_color
        self.colors["entry"] = entry_color
        
        # Save settings
        save_json(SETTINGS_FILE, settings)
        
        # Update the dialog
        self.configure(fg_color=self.colors["bg"])
        self.settings_frame.configure(fg_color=self.colors["bg"])
        self.preview_frame.configure(fg_color=self.colors["bg"])
        self.buttons_frame.configure(fg_color=self.colors["bg"])
        self.notebook.configure(fg_color=self.colors["bg"])
        
        # Update all tabs
        for tab_name in ["Basic", "Advanced", "Layout", "Styling", "Interface"]:
            tab = self.notebook.tab(tab_name)
            tab.configure(fg_color=self.colors["bg"])
        
        # Update all widgets in the dialog
        for widget in self.winfo_children():
            self.update_widget_colors(widget)
        
        # Update preview
        self.update_preview()
        
        messagebox.showinfo("Interface Settings", "Interface settings applied successfully. Restart the application for full effect.")
        
    def update_widget_colors(self, widget):
        # Recursively update widget colors
        try:
            if isinstance(widget, (ctk.CTkLabel, ctk.CTkButton, ctk.CTkCheckBox, ctk.CTkRadioButton)):
                widget.configure(text_color=self.colors["text"])
            elif isinstance(widget, (ctk.CTkEntry, ctk.CTkComboBox, ctk.CTkTextbox, ctk.CTkSlider)):
                widget.configure(fg_color=self.colors["entry"], text_color=self.colors["text"])
            elif isinstance(widget, (ctk.CTkFrame, ctk.CTkTabview)):
                widget.configure(fg_color=self.colors["bg"])
                
            # Recursively update children
            for child in widget.winfo_children():
                self.update_widget_colors(child)
        except:
            pass
        
    def create_preview_ui(self):
        # Title
        ctk.CTkLabel(self.preview_frame, text="Preview", 
                    font=ctk.CTkFont(size=16, weight="bold"),
                    text_color=self.colors["text"]).pack(pady=10)
        
        # Preview canvas
        self.preview_canvas = tk.Canvas(self.preview_frame, width=600, height=700, bg="white")
        self.preview_canvas.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Configure grid weights
        self.preview_frame.pack_propagate(False)
        
    def create_buttons(self):
        # Export button
        self.export_btn = ctk.CTkButton(self.buttons_frame, text="Export PDF", command=self.export_pdf)
        self.export_btn.pack(side="left", padx=10, pady=10)
        
        # Cancel button
        self.cancel_btn = ctk.CTkButton(self.buttons_frame, text="Cancel", command=self.destroy)
        self.cancel_btn.pack(side="right", padx=10, pady=10)
        
    def browse_watermark(self):
        path = filedialog.askopenfilename(filetypes=[("Images", "*.png *.jpg *.jpeg")])
        if path:
            self.watermark_path_var.set(path)
            self.update_preview()
            
    def clear_watermark(self):
        self.watermark_path_var.set("")
        self.update_preview()
        
    def update_preview(self):
        # Clear canvas
        self.preview_canvas.delete("all")
        
        # Create a temporary image to simulate the PDF preview
        width, height = 600, 700
        preview_img = Image.new('RGB', (width, height), color='white')
        draw = ImageDraw.Draw(preview_img)
        
        # Try to load a font
        try:
            font_size = self.font_size_var.get()
            font_family = self.font_family_var.get()
            
            font = ImageFont.load_default()  # Start with default font
            
            if font_family == "Arial":
                try:
                    font = ImageFont.truetype("arial.ttf", font_size)
                except:
                    try:
                        font = ImageFont.truetype("Arial.ttf", font_size)
                    except:
                        font = ImageFont.load_default()
            elif font_family == "Times New Roman":
                try:
                    font = ImageFont.truetype("times.ttf", font_size)
                except:
                    try:
                        font = ImageFont.truetype("Times.ttf", font_size)
                    except:
                        font = ImageFont.load_default()
        except Exception as e:
            print(f"Font loading error: {e}")
            font = ImageFont.load_default()
            
        # Draw title
        station_name = self.station_name_var.get()
        title = process_arabic_text(station_name)
        draw.text((width//2, 20), title, fill='black', font=font, anchor="mt")
        
        # Draw sample table
        y_pos = 60
        spacing = self.spacing_var.get() * 5
        
        # Sample headers
        headers = ["Point", "COth (mm)", "THme (mm)", "RTV (mm)"]
        x_pos = 20
        
        # Try to load bold font
        try:
            header_font = ImageFont.truetype("arialbd.ttf", font_size)
        except:
            try:
                header_font = ImageFont.truetype("Arial-Bold.ttf", font_size)
            except:
                try:
                    header_font = ImageFont.truetype("arial.ttf", font_size)
                except:
                    header_font = font  # Use regular font as fallback
        
        for header in headers:
            draw.text((x_pos, y_pos), header, fill='black', font=header_font)
            x_pos += 120
            
        y_pos += spacing + 10
        
        # Sample data
        for i in range(8):
            x_pos = 20
            for j in range(4):
                value = f"{i+1}.{j+1}"
                draw.text((x_pos, y_pos), value, fill='black', font=font)
                x_pos += 120
            y_pos += spacing
            
        # Draw watermark if exists
        watermark_path = self.watermark_path_var.get()
        if watermark_path and os.path.exists(watermark_path):
            try:
                watermark = Image.open(watermark_path)
                watermark_size = int(width * (self.watermark_size_var.get() / 100))
                watermark = watermark.resize((watermark_size, watermark_size))
                
                # Apply opacity
                opacity = int(self.watermark_opacity_var.get() * 255)
                watermark.putalpha(opacity)
                
                # Position watermark in center
                x = (width - watermark_size) // 2
                y = (height - watermark_size) // 2
                preview_img.paste(watermark, (x, y), watermark)
            except Exception as e:
                print(f"Watermark error: {e}")
                
        try:
            # Save to temporary file and create PhotoImage
            with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
                temp_path = tmp.name
                preview_img.save(temp_path)
                
            # Create PhotoImage from temporary file
            self.preview_photo = ImageTk.PhotoImage(file=temp_path)
            self.preview_canvas.create_image(width//2, height//2, image=self.preview_photo)
            
            # Keep a reference to the temporary file to prevent garbage collection
            self.temp_path = temp_path
        except Exception as e:
            print(f"Preview error: {e}")
            # Fallback: create a simple text preview
            self.preview_canvas.create_text(width//2, height//2, text="Preview not available", 
                                         font=("Arial", 16), fill="black")
        
    def export_pdf(self):
        # Save settings
        settings["pdf_settings"] = {
            "station_name": self.station_name_var.get(),
            "spacing": self.spacing_var.get(),
            "font_family": self.font_family_var.get(),
            "font_size": self.font_size_var.get(),
            "watermark_path": self.watermark_path_var.get(),
            "watermark_size": self.watermark_size_var.get(),
            "watermark_opacity": self.watermark_opacity_var.get(),
            "page_orientation": self.orientation_var.get(),
            "margin_top": self.margin_top_var.get(),
            "margin_bottom": self.margin_bottom_var.get(),
            "margin_left": self.margin_left_var.get(),
            "margin_right": self.margin_right_var.get(),
            "include_interface": self.include_interface_var.get(),
            "include_notes_at_end": self.include_notes_at_end_var.get(),
            "interface_title": self.interface_title_var.get(),
            "notes_title": self.notes_title_var.get(),
            "header_font_size": self.header_font_size_var.get(),
            "table_font_size": self.table_font_size_var.get(),
            "notes_font_size": self.notes_font_size_var.get(),
            "table_border_color": self.table_border_color_var.get(),
            "table_header_color": self.table_header_color_var.get(),
            "table_row_color": self.table_row_color_var.get(),
        }
        save_json(SETTINGS_FILE, settings)
        
        # Get export path
        path = filedialog.asksaveasfilename(
            defaultextension=".pdf", 
            filetypes=[("PDF files", "*.pdf")],
            initialfile=f"{self.station_name_var.get().replace(' ', '_')}_Report.pdf"
        )
        
        if not path:
            return
            
        # Create PDF
        self.create_pdf(path)
        
        messagebox.showinfo("Export", "PDF exported successfully.")
        self.destroy()
        
    def create_pdf(self, path):
        # Get settings
        station_name = self.station_name_var.get()
        spacing = self.spacing_var.get()
        font_family = self.font_family_var.get()
        font_size = self.font_size_var.get()
        watermark_path = self.watermark_path_var.get()
        watermark_size = self.watermark_size_var.get() / 100
        watermark_opacity = self.watermark_opacity_var.get()
        orientation = self.orientation_var.get()
        margin_top = self.margin_top_var.get()
        margin_bottom = self.margin_bottom_var.get()
        margin_left = self.margin_left_var.get()
        margin_right = self.margin_right_var.get()
        include_interface = self.include_interface_var.get()
        include_notes_at_end = self.include_notes_at_end_var.get()
        interface_title = self.interface_title_var.get()
        notes_title = self.notes_title_var.get()
        header_font_size = self.header_font_size_var.get()
        table_font_size = self.table_font_size_var.get()
        notes_font_size = self.notes_font_size_var.get()
        table_border_color = self.table_border_color_var.get()
        table_header_color = self.table_header_color_var.get()
        table_row_color = self.table_row_color_var.get()
        
        # Set page size based on orientation
        if orientation == "landscape":
            page_size = (A4[1], A4[0])  # Swap width and height for landscape
        else:
            page_size = A4
            
        # Create PDF document
        doc = SimpleDocTemplate(
            path,
            pagesize=page_size,
            leftMargin=margin_left * cm,
            rightMargin=margin_right * cm,
            topMargin=margin_top * cm,
            bottomMargin=margin_bottom * cm
        )
        
        # Set up fonts
        try:
            if font_family == "Arial":
                regular_font = "Arial"
                bold_font = "Arial-Bold"
            elif font_family == "Times New Roman":
                regular_font = "TimesNewRoman"
                bold_font = "TimesNewRoman-Bold"
            else:
                regular_font = "Helvetica"
                bold_font = "Helvetica-Bold"
        except:
            regular_font = "Helvetica"
            bold_font = "Helvetica-Bold"
            
        # Create styles
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontName=bold_font,
            fontSize=header_font_size,
            alignment=TA_CENTER,
            spaceAfter=20
        )
        
        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading2'],
            fontName=bold_font,
            fontSize=header_font_size - 2,
            spaceAfter=12
        )
        
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontName=regular_font,
            fontSize=table_font_size,
            spaceAfter=6
        )
        
        notes_style = ParagraphStyle(
            'CustomNotes',
            parent=styles['Normal'],
            fontName=regular_font,
            fontSize=notes_font_size,
            spaceAfter=6
        )
        
        # Build document elements
        elements = []
        
        # Add title
        title_text = process_arabic_text(station_name)
        elements.append(Paragraph(title_text, title_style))
        
        # Add date
        date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        date_para = Paragraph(f"<para alignment=right>{date_str}</para>", normal_style)
        elements.append(date_para)
        
        # Include interface screenshot if requested
        if include_interface:
            elements.append(PageBreak())
            elements.append(Paragraph(process_arabic_text(interface_title), heading_style))
            
            # Capture the interface
            try:
                # Get the root window
                root = self.master
                x = root.winfo_rootx()
                y = root.winfo_rooty()
                width1 = root.winfo_width()
                height1 = root.winfo_height()
                
                # Create a temporary file for the screenshot
                with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
                    temp_path = tmp.name
                
                # Take screenshot using PIL
                import PIL.ImageGrab as ImageGrab
                screenshot = ImageGrab.grab(bbox=(x, y, x + width1, y + height1))
                screenshot.save(temp_path)
                
                # Add image to document
                img = RLImage(temp_path, width=15*cm, height=10*cm)
                elements.append(img)
                
                # Clean up temporary file
                os.unlink(temp_path)
            except Exception as e:
                print(f"Interface screenshot error: {e}")
                elements.append(Paragraph("Interface screenshot not available", normal_style))
        
        # Add Excel data if available
        if self.excel_data:
            elements.append(PageBreak())
            elements.append(Paragraph("Excel Data", heading_style))
            
            for record in self.excel_data:
                # Create part header
                part_text = process_arabic_text(f"Part: {record['part_name']}")
                elements.append(Paragraph(part_text, heading_style))
                
                # Add diameter
                if record.get('diameter'):
                    dia_text = f"Diameter: {record['diameter']} mm"
                    elements.append(Paragraph(dia_text, normal_style))
                
                # Draw table
                headers = record['headers']
                data = record['data']
                
                # Prepare table data
                table_data = [headers]
                table_data.extend(data)
                
                # Create table
                table = Table(table_data)
                
                # Style table
                style = TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), HexColor(table_header_color)),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), bold_font),
                    ('FONTSIZE', (0, 0), (-1, 0), table_font_size),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), HexColor(table_row_color)),
                    ('FONTNAME', (0, 1), (-1, -1), regular_font),
                    ('FONTSIZE', (0, 1), (-1, -1), table_font_size),
                    ('GRID', (0, 0), (-1, -1), 1, HexColor(table_border_color))
                ])
                table.setStyle(style)
                
                elements.append(table)
                elements.append(Paragraph("<br/><br/>", normal_style))
        
        # Process each record
        notes_and_images = []
        
        for rec in self.records:
            # Get part info
            part_name = rec["meta"].get("part_name", "-")
            diameter = rec["meta"].get("diameter", "-") or "-"
            notes = rec["meta"].get("notes", "")
            photo_path = rec["meta"].get("photo", "")
            
            # Store notes and images for later if requested
            if include_notes_at_end and (notes or photo_path):
                notes_and_images.append({
                    "part_name": part_name,
                    "notes": notes,
                    "photo_path": photo_path
                })
            
            # Create part header
            part_text = process_arabic_text(f"Part: {part_name}")
            elements.append(Paragraph(part_text, heading_style))
            
            # Add diameter
            dia_text = f"Diameter: {diameter} mm"
            elements.append(Paragraph(dia_text, normal_style))
            
            # Add date/time
            date_text = rec["meta"].get("datetime", "")
            elements.append(Paragraph(f"<para alignment=right>{date_text}</para>", normal_style))
            
            # Draw table
            headers = rec["headers"]
            data = rec["data"]
            
            # Prepare table data
            table_data = [headers]
            table_data.extend(data)
            
            # Create table
            table = Table(table_data)
            
            # Style table
            style = TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), HexColor(table_header_color)),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), bold_font),
                ('FONTSIZE', (0, 0), (-1, 0), table_font_size),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), HexColor(table_row_color)),
                ('FONTNAME', (0, 1), (-1, -1), regular_font),
                ('FONTSIZE', (0, 1), (-1, -1), table_font_size),
                ('GRID', (0, 0), (-1, -1), 1, HexColor(table_border_color))
            ])
            table.setStyle(style)
            
            elements.append(table)
            elements.append(Paragraph("<br/><br/>", normal_style))
        
        # Add notes and images at the end if requested
        if include_notes_at_end and notes_and_images:
            elements.append(PageBreak())
            elements.append(Paragraph(process_arabic_text(notes_title), title_style))
            
            for item in notes_and_images:
                # Draw part name
                part_text = process_arabic_text(f"Part: {item['part_name']}")
                elements.append(Paragraph(part_text, heading_style))
                
                # Draw notes if available
                if item['notes']:
                    notes_text = item['notes']
                    elements.append(Paragraph(notes_text, notes_style))
                
                # Draw image if available
                if item['photo_path'] and os.path.exists(item['photo_path']):
                    try:
                        # Add image to document
                        img = RLImage(item['photo_path'], width=10*cm, height=7*cm)
                        elements.append(img)
                    except Exception as e:
                        print(f"Image error: {e}")
                        elements.append(Paragraph("Image not available", notes_style))
                
                elements.append(Paragraph("<br/><br/>", notes_style))
        
        # Build PDF
        doc.build(elements)
# --------------------------------------------------
class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Ultra-Pipe Inspection – Giant")
        self.geometry("1600x1000")
        self.resizable(True, True)  # Make window resizable
        self.minsize(1200, 800)  # Set minimum size
        self.colors = THEMES[settings["theme"]]
        self.memory = load_json(MEMORY_FILE, {})
        self.records = list(self.memory.values())[-500:]
        self.current_session_records = []  # Store records from current session
        self.excel_records = []  # Store records from Excel file
        self.setup_vars()
        self.build_ui()
        self.setup_arrow_navigation()  # Setup arrow key navigation
        # Load existing data from database on startup
        self.load_existing_data()
        
        # Add Arabic text processing method
        self.process_arabic_text = process_arabic_text
        
    def setup_vars(self):
        self.part_name  = tk.StringVar()
        self.diameter   = tk.StringVar()
        self.coth_vals  = tk.StringVar()
        self.thme_vals  = tk.StringVar()
        self.old_vals   = tk.StringVar()
        self.old_check  = tk.BooleanVar()
        self.excel_path = tk.StringVar(value=settings.get("last_excel", ""))
        self.photo_path = tk.StringVar()
        
    # ---------- UI ----------
    def build_ui(self):
        # Configure grid weights for resizing
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        main = ctk.CTkFrame(self, fg_color=self.colors["bg"])  # whole window
        main.pack(fill="both", expand=True, padx=8, pady=8)
        main.grid_columnconfigure(0, weight=3)  # Left panel
        main.grid_columnconfigure(1, weight=7)  # Right panel
        
        # LEFT panel (inputs)
        left = ctk.CTkFrame(main, fg_color=self.colors["bg"])
        left.grid(row=0, column=0, sticky="nsew", padx=(0, 8))
        left.grid_columnconfigure(0, weight=2)  # Input fields column
        left.grid_columnconfigure(1, weight=1)  # Description labels column
        left.grid_rowconfigure(12, weight=1)  # Make notes area expandable
        self.build_left(left)
        
        # RIGHT panel: split into center (tabs) + side (Extra)
        right = ctk.CTkFrame(main, fg_color=self.colors["bg"])  # container
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_columnconfigure(0, weight=8)  # Center tabs
        right.grid_columnconfigure(1, weight=2)  # Sidebar
        
        center = ctk.CTkFrame(right, fg_color=self.colors["bg"])  # tabs area
        center.grid(row=0, column=0, sticky="nsew", padx=(0, 8))
        
        sidebar = ctk.CTkFrame(right, fg_color=self.colors["bg"])  # EXTRA on the right
        sidebar.grid(row=0, column=1, sticky="nsew")
        
        self.build_right(center, sidebar)
        
    def build_left(self, parent):
        # Configure grid weights for better scaling
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_rowconfigure(11, weight=1)  # Make notes area expandable
        
        # Part Name - Clear and descriptive label
        ctk.CTkLabel(parent, text="Part Name *", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=0, column=0, sticky="w", padx=10, pady=(15, 5))
        #ctk.CTkLabel(parent, text="Enter the name or identifier of the pipe/part being inspected", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=0, column=1, sticky="w", padx=(0, 10), pady=(15, 5))
        self.part_entry = ctk.CTkEntry(parent, textvariable=self.part_name, placeholder_text="Enter part name (e.g., Pipe-001)", fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.part_entry.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10))
        
        # Diameter - Clear and descriptive label
        ctk.CTkLabel(parent, text="Diameter (mm) *", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=2, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Enter the diameter of the pipe in millimeters", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=2, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.dia_entry = ctk.CTkEntry(parent, textvariable=self.diameter, placeholder_text="Enter diameter in mm (e.g., 219)", fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.dia_entry.grid(row=3, column=0, sticky="ew", padx=10, pady=(0, 10))
        
        # COth (Coating Thickness) - Clear and descriptive label
        ctk.CTkLabel(parent, text="Coating Thickness (mm) *", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=4, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Enter coating thickness measurements separated by spaces", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=4, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.coth_entry = ctk.CTkEntry(parent, textvariable=self.coth_vals, placeholder_text="Enter COth values separated by spaces (e.g., 2.5 3.1 2.8)", fg_color=self.colors["entry"], text_color=self.colors["text"])  
        self.coth_entry.grid(row=5, column=0, sticky="ew", padx=10, pady=(0, 5))
        self.coth_lbl = ctk.CTkLabel(parent, text="Count: 0", text_color=self.colors["text"])  
        self.coth_lbl.grid(row=5, column=1, sticky="w", padx=(0, 10), pady=(0, 5))
        
        # THme (Thickness Measurement) - Clear and descriptive label
        ctk.CTkLabel(parent, text="Thickness Measurement (mm) *", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=6, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Enter wall thickness measurements separated by spaces", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=6, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.thme_entry = ctk.CTkEntry(parent, textvariable=self.thme_vals, placeholder_text="Enter THme values separated by spaces (e.g., 8.2 8.5 8.1)", fg_color=self.colors["entry"], text_color=self.colors["text"])  
        self.thme_entry.grid(row=7, column=0, sticky="ew", padx=10, pady=(0, 5))
        self.thme_lbl = ctk.CTkLabel(parent, text="Count: 0", text_color=self.colors["text"])  
        self.thme_lbl.grid(row=7, column=1, sticky="w", padx=(0, 10), pady=(0, 5))
        
        # Old Thickness - Clear and descriptive label
        self.old_check_box = ctk.CTkCheckBox(parent, text="Include Old Thickness", variable=self.old_check, command=self.toggle_old, text_color=self.colors["text"])
        self.old_check_box.grid(row=8, column=0, sticky="w", padx=10, pady=(10, 0))
        #ctk.CTkLabel(parent, text="Check this box if you want to include previous thickness measurements", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=8, column=1, sticky="w", padx=(0, 10), pady=(10, 0))
        
        ctk.CTkLabel(parent, text="Old Thickness Values (mm)", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=9, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Enter previous thickness measurements separated by spaces", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=9, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.old_entry = ctk.CTkEntry(parent, textvariable=self.old_vals, placeholder_text="Enter old thickness values separated by spaces (e.g., 8.0 8.3 7.9)", fg_color=self.colors["entry"], text_color=self.colors["text"])  
        self.old_entry.grid(row=10, column=0, sticky="ew", padx=10, pady=(0, 5))
        self.old_lbl = ctk.CTkLabel(parent, text="Count: 0", text_color=self.colors["text"])  
        self.old_lbl.grid(row=10, column=1, sticky="w", padx=(0, 10), pady=(0, 5))
        
        # Notes - Clear and descriptive label
        ctk.CTkLabel(parent, text="Notes / Comments", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=11, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Add any additional notes, observations, or comments about the inspection", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=11, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.notes = ctk.CTkTextbox(parent, fg_color=self.colors["entry"], text_color=self.colors["text"])
        self.notes.grid(row=12, column=0, sticky="nsew", padx=10, pady=(0, 10))
        
        # Photo - Clear and descriptive label
        ctk.CTkLabel(parent, text="Photo (optional)", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).grid(row=13, column=0, sticky="w", padx=10, pady=(10, 5))
        #ctk.CTkLabel(parent, text="Add a photo of the pipe/part for visual reference", text_color=self.colors["text"], font=ctk.CTkFont(size=12)).grid(row=13, column=1, sticky="w", padx=(0, 10), pady=(10, 5))
        self.photo_btn = ctk.CTkButton(parent, text="Browse Photo", command=self.browse_photo)
        self.photo_btn.grid(row=14, column=0, sticky="ew", padx=10, pady=(0, 5))
        self.photo_lbl = ctk.CTkLabel(parent, text="No photo selected", text_color=self.colors["text"])  
        self.photo_lbl.grid(row=15, column=0, sticky="w", padx=10, pady=(0, 10))
        
        # Buttons
        btn_frame = ctk.CTkFrame(parent, fg_color=self.colors["bg"])
        btn_frame.grid(row=16, column=0, sticky="ew", pady=10, padx=10)
        
        self.calc_btn = ctk.CTkButton(btn_frame, text="Calculate & Save (Ctrl+S)", command=self.calculate)
        self.calc_btn.pack(fill="x", pady=2)
        
        self.clear_btn = ctk.CTkButton(btn_frame, text="Clear Form", command=self.clear_form)
        self.clear_btn.pack(fill="x", pady=2)
        
        # Behavior: space -> visual separator " | "
        for entry in (self.coth_entry, self.thme_entry, self.old_entry):
            entry.bind("<space>", self._insert_separator)
            
        self.toggle_old()
        self.bind_counts()
        
    def build_right(self, center_parent, sidebar_parent):
        # top bar over center tabs
        top = ctk.CTkFrame(center_parent, fg_color=self.colors["bg"])
        top.pack(fill="x", padx=5, pady=5)
        
        ctk.CTkLabel(top, text="Excel File:", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).pack(side="left")
        self.excel_path_label = ctk.CTkLabel(top, textvariable=self.excel_path, width=350, text_color=self.colors["text"])
        self.excel_path_label.pack(side="left", padx=5)
        
        ctk.CTkButton(top, text="Open", width=80, command=self.open_excel).pack(side="right", padx=5)
        ctk.CTkButton(top, text="Browse", width=80, command=self.browse_excel).pack(side="right")
        ctk.CTkButton(top, text="Clear", width=80, command=self.clear_excel).pack(side="right")
        
        # notebook
        nb = ctk.CTkTabview(center_parent)
        nb.pack(fill="both", expand=True, padx=5, pady=5)
        nb.add("Results")
        nb.add("History")
        nb.add("DB")
        nb.add("Charts")
        nb.add("Analysis")
        nb.add("Settings")
        
        # Results (monospace for correct tabulate alignment)
        res_tab = nb.tab("Results")
        font_family = "Courier New" if settings.get("monospace", True) else None
        self.header_label = ctk.CTkLabel(res_tab, text="", text_color=self.colors["text"], anchor="w")
        self.header_label.pack(fill="x", padx=6, pady=(6, 0))
        
        # Create frame for results with scrollbar
        results_frame = ctk.CTkFrame(res_tab, fg_color=self.colors["bg"])
        results_frame.pack(fill="both", expand=True, padx=6, pady=6)
        
        # Create scrollbar
        results_scrollbar = ctk.CTkScrollbar(results_frame)
        results_scrollbar.pack(side="right", fill="y")
        
        # Create textbox
        self.result_text = ctk.CTkTextbox(
            results_frame,
            wrap="none",
            fg_color=self.colors["entry"],
            text_color=self.colors["text"],
            font=(font_family, 12) if font_family else None,
            yscrollcommand=results_scrollbar.set
        )
        self.result_text.pack(side="left", fill="both", expand=True)
        
        # Configure scrollbar
        results_scrollbar.configure(command=self.result_text.yview)
        
        # History
        h_frame = ctk.CTkFrame(nb.tab("History"), fg_color=self.colors["bg"])
        h_frame.pack(fill="both", expand=True)
        
        # Configure grid weights for proper scaling
        h_frame.grid_columnconfigure(0, weight=1)
        h_frame.grid_rowconfigure(1, weight=1)
        h_frame.grid_rowconfigure(2, weight=2)
        
        # Search frame
        search_frame = ctk.CTkFrame(h_frame, fg_color=self.colors["bg"])
        search_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        ctk.CTkLabel(search_frame, text="Search:", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).pack(side="left", padx=5)
        self.search_var = tk.StringVar()
        self.search_entry = ctk.CTkEntry(search_frame, textvariable=self.search_var)
        self.search_entry.pack(side="left", fill="x", expand=True, padx=5)
        self.search_var.trace_add("write", self.filter_history)
        
        # History table - Improved layout with proper scaling
        history_table_frame = ctk.CTkFrame(h_frame, fg_color=self.colors["bg"])
        history_table_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        # Create treeview for history with better column sizing
        self.history_tree = ttk.Treeview(history_table_frame, columns=("part_name", "datetime", "diameter"), show="headings")
        self.history_tree.heading("part_name", text="Part Name")
        self.history_tree.heading("datetime", text="Date/Time")
        self.history_tree.heading("diameter", text="Diameter")
        
        # Configure column widths with better proportions
        self.history_tree.column("part_name", width=300, minwidth=200)
        self.history_tree.column("datetime", width=200, minwidth=150)
        self.history_tree.column("diameter", width=120, minwidth=100)
        
        # Add scrollbar
        history_scrollbar = ttk.Scrollbar(history_table_frame, orient="vertical", command=self.history_tree.yview)
        self.history_tree.configure(yscrollcommand=history_scrollbar.set)
        
        self.history_tree.pack(side="left", fill="both", expand=True)
        history_scrollbar.pack(side="right", fill="y")
        
        # Bind selection event
        self.history_tree.bind("<<TreeviewSelect>>", self.show_history_record)
        
        # History details - Much larger and properly scaled
        details_frame = ctk.CTkFrame(h_frame, fg_color=self.colors["bg"])
        details_frame.grid(row=2, column=0, sticky="nsew", padx=5, pady=5)
        
        # Header frame with label and exit button
        history_header_frame = ctk.CTkFrame(details_frame, fg_color=self.colors["bg"])
        history_header_frame.pack(fill="x", padx=15, pady=(40, 15))
        
        ctk.CTkLabel(history_header_frame, text="Part Details", text_color=self.colors["text"], 
                    font=ctk.CTkFont(size=20, weight="bold")).pack(side="left", pady=10)
        
        # Exit button to clear details
        self.history_exit_btn = ctk.CTkButton(history_header_frame, text="Exit Details", command=self.history_clear_details, width=120)
        self.history_exit_btn.pack(side="right", padx=15, pady=10)
        
        # Create frame for details with scrollbar (same as Results tab)
        details_inner_frame = ctk.CTkFrame(details_frame, fg_color=self.colors["bg"])
        details_inner_frame.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Create scrollbar
        details_scrollbar = ctk.CTkScrollbar(details_inner_frame)
        details_scrollbar.pack(side="right", fill="y")
        
        # Create textbox with same styling as Results tab
        self.history_text = ctk.CTkTextbox(
            details_inner_frame,
            wrap="none",
            fg_color=self.colors["entry"],
            text_color=self.colors["text"],
            font=("Courier New", 12),  # Same font as Results tab
            yscrollcommand=details_scrollbar.set
        )
        self.history_text.pack(side="left", fill="both", expand=True)
        
        # Configure scrollbar
        details_scrollbar.configure(command=self.history_text.yview)
        
        # DB Tab
        db_tab = nb.tab("DB")
        self.build_db_tab(db_tab)
        
        # Charts Tab
        charts_tab = nb.tab("Charts")
        self.build_charts_tab(charts_tab)
        
        # Analysis Tab
        analysis_tab = nb.tab("Analysis")
        self.build_analysis_tab(analysis_tab)
        
        # Settings (inside tabs area as requested to be near Results/History)
        set_tab = nb.tab("Settings")
        self._build_settings(set_tab)
        
        # Sidebar (EXTRA) on the right side
        ctk.CTkLabel(sidebar_parent, text="أدوات إضافية", text_color=self.colors["text"], font=("", 14, "bold")).pack(pady=(10, 6))
        
        # Add general notes button
        self.add_notes_btn = ctk.CTkButton(
            sidebar_parent, 
            text="إضافة ملاحظات عامة", 
            command=self.add_general_notes,
            width=180
        )
        self.add_notes_btn.pack(pady=5, padx=10)
        
        self.export_csv_btn = ctk.CTkButton(sidebar_parent, text="Export CSV", command=self.export_csv)
        self.export_csv_btn.pack(fill="x", padx=8, pady=4)
        
        self.export_pdf_btn = ctk.CTkButton(sidebar_parent, text="Export PDF (Ctrl+E)", command=self.export_pdf)
        self.export_pdf_btn.pack(fill="x", padx=8, pady=4)
        
        self.open_excel_btn = ctk.CTkButton(sidebar_parent, text="Open Excel", command=self.open_excel)
        self.open_excel_btn.pack(fill="x", padx=8, pady=4)
        
        # Keyboard shortcuts
        self.bind_all("<Control-s>", lambda e: self.calculate())
        self.bind_all("<Control-S>", lambda e: self.calculate())
        self.bind_all("<Control-e>", lambda e: self.export_pdf())
        self.bind_all("<Control-E>", lambda e: self.export_pdf())
        
        self.refresh_history_list()
        
    def load_existing_data(self):
        """Load existing data from database on startup"""
        try:
            # Load records from database
            db_records = search_db_records()
            if db_records:
                # Convert database records to the format expected by the app
                for record in db_records:
                    converted_record = {
                        "meta": {
                            "part_name": record["part_name"],
                            "diameter": record["diameter"],
                            "notes": record["notes"],
                            "photo": record["photo_path"],
                            "datetime": record["datetime"],
                        },
                        "headers": record["headers"],
                        "data": record["data"]
                    }
                    self.excel_records.append(converted_record)
                
                # Refresh the display
                self.refresh_history_list()
            
            # Load database records if tree exists
            if hasattr(self, 'db_tree'):
                self.db_load_records()
            
            # Update charts tab parts list
            if hasattr(self, 'parts_listbox'):
                self.update_parts_list()
                    
        except Exception as e:
            print(f"Error loading existing data: {e}")
        
    def build_db_tab(self, parent):
        # Create main frame with proper grid configuration
        main_frame = ctk.CTkFrame(parent, fg_color=self.colors["bg"])
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configure grid weights for proper scaling
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(1, weight=1)
        main_frame.grid_rowconfigure(2, weight=2)
        
        # Top frame for search and filters
        top_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        top_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        # Search
        ctk.CTkLabel(top_frame, text="Search:", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).pack(side="left", padx=5)
        self.db_search_var = tk.StringVar()
        self.db_search_entry = ctk.CTkEntry(top_frame, textvariable=self.db_search_var, width=200)
        self.db_search_entry.pack(side="left", padx=5)
        
        # Search button
        self.db_search_btn = ctk.CTkButton(top_frame, text="Search", command=self.db_search)
        self.db_search_btn.pack(side="left", padx=5)
        
        # Filters button
        self.db_filters_btn = ctk.CTkButton(top_frame, text="Filters", command=self.db_open_filters)
        self.db_filters_btn.pack(side="left", padx=5)
        
        # Show All button
        self.db_show_all_btn = ctk.CTkButton(top_frame, text="Show All", command=self.db_show_all)
        self.db_show_all_btn.pack(side="left", padx=5)
        
        # New database button
        self.db_new_btn = ctk.CTkButton(top_frame, text="New Database", command=self.db_new_database)
        self.db_new_btn.pack(side="right", padx=5)
        
        # Table frame with improved layout
        table_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        table_frame.grid(row=1, column=0, sticky="nsew")
        
        # Create treeview for DB records with better formatting
        self.db_tree = ttk.Treeview(table_frame, columns=("id", "part_name", "diameter", "datetime", "source_file"), show="headings")
        self.db_tree.heading("id", text="ID")
        self.db_tree.heading("part_name", text="Part Name")
        self.db_tree.heading("diameter", text="Diameter")
        self.db_tree.heading("datetime", text="Date/Time")
        self.db_tree.heading("source_file", text="Source File")
        
        # Configure column widths with better proportions and minimum widths
        self.db_tree.column("id", width=60, minwidth=50)
        self.db_tree.column("part_name", width=250, minwidth=200)
        self.db_tree.column("diameter", width=120, minwidth=100)
        self.db_tree.column("datetime", width=180, minwidth=150)
        self.db_tree.column("source_file", width=300, minwidth=200)
        
        # Add scrollbar
        db_scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.db_tree.yview)
        self.db_tree.configure(yscrollcommand=db_scrollbar.set)
        
        self.db_tree.pack(side="left", fill="both", expand=True)
        db_scrollbar.pack(side="right", fill="y")
        
        # Bind both double-click and selection change to show details
        self.db_tree.bind("<Double-1>", self.db_show_details)
        self.db_tree.bind("<<TreeviewSelect>>", self.db_show_details)
        
        # Details frame with better scaling
        self.db_details_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        self.db_details_frame.grid(row=2, column=0, sticky="nsew", pady=(10, 0))
        
        # Header frame with label and exit button
        header_frame = ctk.CTkFrame(self.db_details_frame, fg_color=self.colors["bg"])
        header_frame.pack(fill="x", padx=15, pady=(10, 15))
        
        ctk.CTkLabel(header_frame, text="Record Details", text_color=self.colors["text"], 
                    font=ctk.CTkFont(size=18, weight="bold")).pack(side="left", pady=10)
        
        # Exit button to clear details
        self.db_exit_btn = ctk.CTkButton(header_frame, text="Exit Details", command=self.db_clear_details, width=120)
        self.db_exit_btn.pack(side="right", padx=15, pady=10)
        
        # Create frame for details with scrollbar (same as Results tab)
        details_inner_frame = ctk.CTkFrame(self.db_details_frame, fg_color=self.colors["bg"])
        details_inner_frame.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Create scrollbar
        details_scrollbar = ctk.CTkScrollbar(details_inner_frame)
        details_scrollbar.pack(side="right", fill="y")
        
        # Create textbox with same styling as Results tab
        self.db_details_text = ctk.CTkTextbox(
            details_inner_frame,
            wrap="none",
            fg_color=self.colors["entry"],
            text_color=self.colors["text"],
            font=("Courier New", 12),  # Same font as Results tab
            yscrollcommand=details_scrollbar.set
        )
        self.db_details_text.pack(side="left", fill="both", expand=True)
        
        # Configure scrollbar
        details_scrollbar.configure(command=self.db_details_text.yview)
        
        # Initially load all records
        self.db_load_records()
    
    def db_show_all(self):
        """Show all records without any filters"""
        self.db_load_records()
        
    def build_charts_tab(self, parent):
        # Create main frame with proper grid configuration
        main_frame = ctk.CTkFrame(parent, fg_color=self.colors["bg"])
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configure grid weights for proper scaling
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(4, weight=1)  # Chart frame gets most space
        
        # Top frame for controls
        top_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        top_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        # Chart type selection
        ctk.CTkLabel(top_frame, text="Chart Type:", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).pack(side="left", padx=5)
        self.chart_type_var = tk.StringVar(value="line")
        chart_types = ["line", "bar", "scatter", "pie", "box", "histogram"]
        self.chart_type_combo = ctk.CTkComboBox(top_frame, variable=self.chart_type_var, values=chart_types, width=150)
        self.chart_type_combo.pack(side="left", padx=5)
        
        # Data selection
        ctk.CTkLabel(top_frame, text="Data:", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).pack(side="left", padx=(20, 5))
        self.chart_data_var = tk.StringVar(value="thickness")
        data_types = ["thickness", "coating", "corrosion", "all"]
        self.chart_data_combo = ctk.CTkComboBox(top_frame, variable=self.chart_data_var, values=data_types, width=150)
        self.chart_data_combo.pack(side="left", padx=5)
        
        # Generate button
        self.generate_chart_btn = ctk.CTkButton(top_frame, text="Generate Chart", command=self.generate_chart)
        self.generate_chart_btn.pack(side="left", padx=20)
        
        # Download button
        self.download_chart_btn = ctk.CTkButton(top_frame, text="Download Chart", command=self.download_chart, state="disabled")
        self.download_chart_btn.pack(side="left", padx=5)
        
        # Part selection frame
        parts_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        parts_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        ctk.CTkLabel(parts_frame, text="Select Parts:", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).pack(side="left", padx=5)
        
        # Select all button
        self.select_all_btn = ctk.CTkButton(parts_frame, text="Select All", command=self.select_all_parts, width=100)
        self.select_all_btn.pack(side="left", padx=5)
        
        # Clear selection button
        self.clear_selection_btn = ctk.CTkButton(parts_frame, text="Clear Selection", command=self.clear_part_selection, width=120)
        self.clear_selection_btn.pack(side="left", padx=5)
        
        # Parts listbox with scrollbar - Improved sizing
        parts_list_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        parts_list_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        
        self.parts_listbox = tk.Listbox(parts_list_frame, selectmode="multiple", height=8, 
                                       bg=self.colors["entry"], fg=self.colors["text"], 
                                       selectbackground="#0078d4", selectforeground="white",
                                       font=("Arial", 12))  # Larger font for better readability
        self.parts_listbox.pack(side="left", fill="x", expand=True, padx=5)
        
        parts_scrollbar = ctk.CTkScrollbar(parts_list_frame, command=self.parts_listbox.yview)
        parts_scrollbar.pack(side="right", fill="y")
        self.parts_listbox.configure(yscrollcommand=parts_scrollbar.set)
        
        # Chart frame with proper scaling
        self.chart_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        self.chart_frame.grid(row=4, column=0, sticky="nsew")
        
        # Initially empty
        self.chart_figure = None
        self.chart_canvas = None
        
        # Update parts list when tab is built
        self.update_parts_list()
        
    def update_parts_list(self):
        """Update the parts listbox with available parts"""
        self.parts_listbox.delete(0, tk.END)
        all_records = self.current_session_records + self.excel_records
        
        for record in all_records:
            if isinstance(record, dict) and "meta" in record:
                part_name = record["meta"].get("part_name", "Unknown")
                self.parts_listbox.insert(tk.END, part_name)
    
    def select_all_parts(self):
        """Select all parts in the listbox"""
        for i in range(self.parts_listbox.size()):
            self.parts_listbox.selection_set(i)
    
    def clear_part_selection(self):
        """Clear all selections in the parts listbox"""
        self.parts_listbox.selection_clear(0, tk.END)
        
    def build_analysis_tab(self, parent):
        # Create main frame with proper grid configuration
        main_frame = ctk.CTkFrame(parent, fg_color=self.colors["bg"])
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configure grid weights for proper scaling
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(1, weight=1)  # Analysis results get most space
        
        # Top frame for controls
        top_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        top_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        # Analysis type selection
        ctk.CTkLabel(top_frame, text="Analysis Type:", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).pack(side="left", padx=5)
        self.analysis_type_var = tk.StringVar(value="basic")
        analysis_types = ["basic", "statistical", "trend", "correlation", "machine_learning", "comprehensive"]
        self.analysis_type_combo = ctk.CTkComboBox(top_frame, variable=self.analysis_type_var, values=analysis_types, width=150)
        self.analysis_type_combo.pack(side="left", padx=5)
        
        # Data source selection
        ctk.CTkLabel(top_frame, text="Data Source:", text_color=self.colors["text"], font=ctk.CTkFont(size=16, weight="bold")).pack(side="left", padx=(20, 5))
        self.analysis_data_var = tk.StringVar(value="all")
        data_sources = ["all", "current_session", "excel_file", "database"]
        self.analysis_data_combo = ctk.CTkComboBox(top_frame, variable=self.analysis_data_var, values=data_sources, width=150)
        self.analysis_data_combo.pack(side="left", padx=5)
        
        # Analyze button
        self.analyze_btn = ctk.CTkButton(top_frame, text="Analyze Data", command=self.analyze_station)
        self.analyze_btn.pack(side="left", padx=20)
        
        # Export analysis button
        self.export_analysis_btn = ctk.CTkButton(top_frame, text="Export Analysis", command=self.export_analysis, state="disabled")
        self.export_analysis_btn.pack(side="left", padx=5)
        
        # Analysis results frame with better scaling
        self.analysis_frame = ctk.CTkFrame(main_frame, fg_color=self.colors["bg"])
        self.analysis_frame.grid(row=1, column=0, sticky="nsew")
        
        # Add a label for the analysis section
        ctk.CTkLabel(self.analysis_frame, text="Analysis Results", text_color=self.colors["text"], 
                    font=ctk.CTkFont(size=18, weight="bold")).pack(pady=(10, 15))
        
        # Analysis text with larger font and better scaling
        self.analysis_text = ctk.CTkTextbox(
            self.analysis_frame,
            wrap="word",
            fg_color=self.colors["entry"],
            text_color=self.colors["text"],
            font=("Arial", 20),  # Larger font for better readability
            height=320 # Increased height for better data display
        )
        self.analysis_text.pack(fill="both", expand=True, padx=15, pady=15)
        
    # ---------- settings UI ----------
    def _build_settings(self, parent):
        wrap = ctk.CTkFrame(parent, fg_color=self.colors["bg"])
        wrap.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Equation controls
        ctk.CTkLabel(wrap, text="RTV Equation", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).grid(row=0, column=0, sticky="w", pady=2)
        self.rtv_eq_var = tk.StringVar(value=settings.get("rtv_eq"))
        ctk.CTkEntry(wrap, textvariable=self.rtv_eq_var, fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=0, column=1, sticky="ew", padx=6)
        
        ctk.CTkLabel(wrap, text="CR Equation", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).grid(row=1, column=0, sticky="w", pady=2)
        self.cr_eq_var = tk.StringVar(value=settings.get("cr_eq"))
        ctk.CTkEntry(wrap, textvariable=self.cr_eq_var, fg_color=self.colors["entry"], text_color=self.colors["text"]).grid(row=1, column=1, sticky="ew", padx=6)
        
        # Theme
        ctk.CTkLabel(wrap, text="Theme", text_color=self.colors["text"], font=ctk.CTkFont(size=14, weight="bold")).grid(row=2, column=0, sticky="w", pady=(8, 2))
        self.theme_var = tk.StringVar(value=settings.get("theme", "dark-blue"))
        ctk.CTkOptionMenu(wrap, values=list(THEMES.keys()), variable=self.theme_var).grid(row=2, column=1, sticky="w", padx=6)
        
        # Monospace toggle
        self.mono_var = tk.BooleanVar(value=settings.get("monospace", True))
        ctk.CTkCheckBox(wrap, text="Use monospace font for tables", variable=self.mono_var, text_color=self.colors["text"]).grid(row=3, column=1, sticky="w", pady=(4, 10))
        
        # RTL for Arabic
        self.rtl_var = tk.BooleanVar(value=settings.get("rtl", True))
        ctk.CTkCheckBox(wrap, text="Right-to-Left for Arabic text", variable=self.rtl_var, text_color=self.colors["text"]).grid(row=4, column=1, sticky="w", pady=(4, 10))
        
        # Save/Exit
        ctk.CTkButton(wrap, text="Save Settings", command=self._save_settings).grid(row=5, column=0, columnspan=2, sticky="ew", pady=4)
        
        wrap.grid_columnconfigure(1, weight=1)
        
    def _save_settings(self):
        settings["rtv_eq"] = self.rtv_eq_var.get().strip() or settings["rtv_eq"]
        settings["cr_eq"] = self.cr_eq_var.get().strip() or settings["cr_eq"]
        settings["theme"] = self.theme_var.get()
        settings["monospace"] = bool(self.mono_var.get())
        settings["rtl"] = bool(self.rtl_var.get())
        save_json(SETTINGS_FILE, settings)
        messagebox.showinfo("Settings", "Settings saved. Please restart to apply changes.")
        
    # ---------- events ----------
    def bind_counts(self):
        for v in (self.coth_vals, self.thme_vals, self.old_vals):
            v.trace_add("write", self.update_counts)
            
    def toggle_old(self):
        st = "normal" if self.old_check.get() else "disabled"
        self.old_entry.configure(state=st)
        self.update_counts()
        
    def update_counts(self, *_):
        self.coth_lbl.configure(text=f"Count: {count_values(self.coth_vals.get())}")
        self.thme_lbl.configure(text=f"Count: {count_values(self.thme_vals.get())}")
        self.old_lbl.configure(text=f"Count: {count_values(self.old_vals.get())}")
        
    def _insert_separator(self, event):
        # Replace a plain space with a clearer visual separator and keep editability
        event.widget.insert("insert", " | ")
        return "break"
        
    def clear_form(self):
        for v in (self.part_name, self.diameter, self.coth_vals, self.thme_vals, self.old_vals):
            v.set("")
        self.notes.delete("1.0", "end")
        self.photo_lbl.configure(image="", text="No photo selected")
        self.photo_path.set("")
        self.old_check.set(False)
        self.toggle_old()
        
    def clear_excel(self):
        self.excel_path.set("")
        settings["last_excel"] = ""
        save_json(SETTINGS_FILE, settings)
        self.excel_records = []
        self.refresh_history_list()
        messagebox.showinfo("Excel File", "Excel file cleared.")
        
    def browse_excel(self):
        path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx")])
        if path:
            self.excel_path.set(path)
            settings["last_excel"] = path
            save_json(SETTINGS_FILE, settings)
            # Load Excel data into current session
            self.load_excel_data()
            
    def load_excel_data(self):
        """Load data from the currently open Excel file into current session"""
        path = settings.get("last_excel", "")
        if not path or not os.path.isfile(path):
            return
            
        try:
            wb = load_workbook(path)
            if "Results" not in wb.sheetnames:
                messagebox.showwarning("Warning", "No 'Results' sheet found in Excel file")
                return
                
            ws = wb["Results"]
            
            # Clear current session records
            self.excel_records = []
            
            # Parse the sheet to extract records
            current_record = None
            current_headers = []
            current_data = []
            
            for row in ws.iter_rows(values_only=True):
                # Skip empty rows
                if not any(cell is not None for cell in row):
                    continue
                    
                # Check if this is a part name row (first cell is not None and others are None)
                if row[0] and not any(row[1:]):
                    # Save previous record if exists
                    if current_record and current_headers and current_data:
                        current_record["headers"] = current_headers
                        current_record["data"] = current_data
                        self.excel_records.append(current_record)
                        # Add to database
                        insert_record_to_db(current_record, source_file=path)
                        
                    # Start new record
                    current_record = {
                        "meta": {
                            "part_name": str(row[0]),
                            "diameter": "",
                            "notes": "",
                            "photo": "",
                            "datetime": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        },
                        "headers": [],
                        "data": []
                    }
                    current_headers = []
                    current_data = []
                    
                # Check if this is a diameter row - but don't treat it as a part name
                elif row[0] and isinstance(row[0], str) and "Diameter:" in str(row[0]):
                    if current_record:
                        # Extract just the diameter value, not the full "Diameter: X mm" text
                        diameter_text = str(row[0]).replace("Diameter:", "").strip()
                        # Remove "mm" if present
                        if "mm" in diameter_text:
                            diameter_text = diameter_text.replace("mm", "").strip()
                        current_record["meta"]["diameter"] = diameter_text
                        
                # Check if this is a header row
                elif row[0] and "Point" in str(row[0]):
                    if current_record:
                        current_headers = [str(cell) for cell in row if cell is not None]
                        
                # Check if this is a data row (starts with number)
                elif row[0] and isinstance(row[0], (int, float)):
                    if current_record and current_headers:
                        current_data.append([cell for cell in row if cell is not None])
                        
                # Check if this is a notes row
                elif row[0] and isinstance(row[0], str) and "Notes:" in str(row[0]):
                    if current_record:
                        # Next row should contain the notes
                        pass
                        
                # This might be the notes content
                elif current_record and not current_record["meta"]["notes"] and row[0]:
                    current_record["meta"]["notes"] = str(row[0])
                    
            # Add the last record
            if current_record and current_headers and current_data:
                current_record["headers"] = current_headers
                current_record["data"] = current_data
                self.excel_records.append(current_record)
                # Add to database
                insert_record_to_db(current_record, source_file=path)
                
            # Refresh history list
            self.refresh_history_list()
            
            # Save data to memory for persistence
            self.save_data_to_memory()
            
            messagebox.showinfo("Success", f"Successfully loaded {len(self.excel_records)} records from Excel file")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error loading Excel data: {e}")
        
    def browse_photo(self):
        path = filedialog.askopenfilename(filetypes=[("Images", "*.png *.jpg *.jpeg")])
        if path:
            try:
                # Open and resize the image
                pil_img = Image.open(path)
                pil_img = pil_img.resize((120, 120))
                
                # Convert to CTkImage properly
                self.photo_img = ctk.CTkImage(light_image=pil_img, dark_image=pil_img, size=(120, 120))
                self.photo_lbl.configure(image=self.photo_img, text="")
                self.photo_path.set(path)
                messagebox.showinfo("Photo", "Photo selected successfully")
            except Exception as e:
                messagebox.showerror("Error", f"Error loading photo: {e}")
            
    def open_excel(self):
        path = settings.get("last_excel", "")
        if os.path.isfile(path):
            os.startfile(path) if os.name == "nt" else os.system(f"xdg-open '{path}'")
            
    # ---------- calculate ----------
    def calculate(self):
        name = self.part_name.get().strip()
        if not name:
            messagebox.showwarning("Input", "Please enter part name.")
            return
            
        path = settings.get("last_excel", "")
        if not os.path.isfile(path):
            messagebox.showwarning("File", "Please select an Excel file first.")
            return
            
        try:
            coth = parse_values(self.coth_vals.get())
            thme = parse_values(self.thme_vals.get())
            old  = parse_values(self.old_vals.get()) if self.old_check.get() else []
            if len(set(map(len, [coth, thme, *(old and [old] or [])]))) != 1:
                messagebox.showerror("عدم تطابق", "يجب أن تكون جميع المتجهات بنفس الطول.")
                return
        except ValueError:
            messagebox.showerror("Value", "Numbers only separated by space, comma, or | .")
            return
            
        rtv = safe_eval(settings["rtv_eq"], coth=np.array(coth), thme=np.array(thme))
        if rtv is None:
            return
            
        cr  = safe_eval(settings["cr_eq"], old_real_thickness=np.array(old), RTV=rtv) if old else None
        
        headers = ["Point", "COth (mm)", "THme (mm)", "RTV (mm)"]
        if cr is not None:
            headers += ["Old (mm)", "CR (mm)"]
            
        table = [[i + 1, c, t, round(r, 2)] + ([old[i], round(cr[i], 2)] if cr is not None else []) 
                 for i, (c, t, r) in enumerate(zip(coth, thme, rtv))]
        
        # display header (part, dia) above data in Results
        dia = (self.diameter.get() or "-")
        self.header_label.configure(text=f"Part: {name}    |    Diameter: {dia} mm")
        
        # display table with proper alignment
        self.result_text.delete("1.0", "end")
        tbl = tabulate(
            table,
            headers=headers,
            tablefmt="github",
            floatfmt=".2f",
            numalign="center",
            stralign="center",
        )
        self.result_text.insert("end", tbl)
        
        # excel
        wb = load_workbook(path) if os.path.isfile(path) else Workbook()
        ws = wb["Results"] if "Results" in wb.sheetnames else wb.create_sheet("Results")
        row = ws.max_row + 2
        
        # Write the part name as a merged header
        ws.cell(row, 1, name).font = Font(bold=True)
        ws.merge_cells(start_row=row, start_column=1, end_row=row, end_column=6)  # Always merge to 6 columns
        ws.cell(row, 1).alignment = Alignment(horizontal='center')
        row += 1
        
        if self.diameter.get():
            ws.cell(row, 1, f"Diameter: {self.diameter.get()} mm").font = Font(bold=True)
            ws.merge_cells(start_row=row, start_column=1, end_row=row, end_column=len(headers))
            row += 1
            
        for c, h in enumerate(headers, 1):
            cell = ws.cell(row, c, h)
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal="center")
            
        for r, d in enumerate(table, row + 1):
            for c, v in enumerate(d, 1):
                ws.cell(r, c, v).alignment = Alignment(horizontal="center")
                
        notes = self.notes.get("1.0", "end").strip()
        if notes:
            r = ws.max_row + 2
            ws.cell(r, 1, "Notes:").font = Font(bold=True)
            ws.merge_cells(start_row=r, start_column=1, end_row=r, end_column=len(headers))
            ws.cell(r + 1, 1, notes)
            
        wb.save(path)
        
        # memory
        now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        key = f"{name} {now_str}"
        record = {
            "headers": headers,
            "data": table,
            "meta": {
                "part_name": name,
                "diameter": self.diameter.get(),
                "notes": notes,
                "photo": self.photo_path.get(),
                "datetime": now_str,
            },
        }
        
        # Add to memory
        self.memory[key] = record
        self.records = list(self.memory.values())[-500:]
        save_json(MEMORY_FILE, self.memory)
        
        # Add to current session records
        self.current_session_records.append(record)
        
        # Add to database
        insert_record_to_db(record, source_file=path)
        
        # Refresh history list
        self.refresh_history_list()
        
        # Save data to memory for persistence
        self.save_data_to_memory()
        
        # Clear form after saving
        self.clear_form()
        
    # ---------- exports ----------
    def export_csv(self):
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        if not all_records:
            messagebox.showwarning("Export", "No data to export.")
            return
            
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")])
        if not path:
            return
            
        with open(path, "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            for rec in all_records:
                writer.writerow([])
                writer.writerow([rec["meta"].get("part_name", ""), rec["meta"].get("datetime", "")])
                writer.writerow(rec["headers"])
                writer.writerows(rec["data"])
                
        messagebox.showinfo("Export", "CSV exported successfully.")
        
    def export_pdf(self):
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        if not all_records:
            messagebox.showwarning("Export", "No data to export.")
            return
            
        # Import Excel data if available
        excel_data = None
        excel_path = settings.get("last_excel", "")
        if excel_path and os.path.isfile(excel_path):
            try:
                wb = load_workbook(excel_path)
                if "Results" in wb.sheetnames:
                    ws = wb["Results"]
                    
                    # Parse the sheet to extract records
                    records = []
                    current_record = None
                    
                    for row in ws.iter_rows(values_only=True):
                        # Skip empty rows
                        if not any(cell is not None for cell in row):
                            continue
                            
                        # Check if this is a part name row
                        if row[0] and not any(row[1:]):
                            # Save previous record if exists
                            if current_record:
                                records.append(current_record)
                                
                            # Start new record
                            current_record = {
                                "part_name": row[0],
                                "diameter": "",
                                "headers": [],
                                "data": []
                            }
                        # Check if this is a diameter row
                        elif row[0] and isinstance(row[0], str) and row[0].startswith("Diameter:"):
                            if current_record:
                                current_record["diameter"] = row[0].replace("Diameter:", "").strip()
                        # Check if this is a header row
                        elif row[0] and "Point" in str(row[0]):
                            if current_record:
                                current_record["headers"] = [str(cell) for cell in row if cell]
                        # Check if this is a data row
                        elif row[0] and isinstance(row[0], (int, float)):
                            if current_record and current_record["headers"]:
                                current_record["data"].append([cell for cell in row if cell is not None])
                                
                    # Add the last record
                    if current_record:
                        records.append(current_record)
                        
                    excel_data = records
            except Exception as e:
                print(f"Error reading Excel data: {e}")
        
        # Show PDF export dialog
        PDFExportDialog(self, all_records, self.colors, excel_data)
        
    # ---------- history ----------
    def filter_history(self, *_):
        term = self.search_var.get().lower()
        
        # Clear existing items
        for item in self.history_tree.get_children():
            self.history_tree.delete(item)
            
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        # Add matching items
        for rec in all_records:
            if isinstance(rec, dict) and "meta" in rec:
                pn = rec["meta"].get("part_name", "Unknown")
                dt = rec["meta"].get("datetime", "No Date")
                dia = rec["meta"].get("diameter", "-") or "-"
                
                if term in pn.lower():
                    self.history_tree.insert("", "end", values=(pn, dt, dia))
                    
    def refresh_history_list(self):
        # Clear existing items
        for item in self.history_tree.get_children():
            self.history_tree.delete(item)
            
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        # Add all items
        for rec in all_records:
            if isinstance(rec, dict) and "meta" in rec:
                pn = rec["meta"].get("part_name", "Unknown")
                dt = rec["meta"].get("datetime", "No Date")
                dia = rec["meta"].get("diameter", "-") or "-"
                
                self.history_tree.insert("", "end", values=(pn, dt, dia))
        
                # Update charts tab parts list if it exists
        if hasattr(self, 'parts_listbox'):
            self.update_parts_list()
        
        # Save data to memory for persistence
        self.save_data_to_memory()
        
    def save_data_to_memory(self):
        """Save current data to memory file for persistence"""
        try:
            # Combine all records
            all_records = self.current_session_records + self.excel_records
            
            # Convert to memory format
            memory_data = {}
            for i, record in enumerate(all_records):
                if isinstance(record, dict) and "meta" in record:
                    key = f"record_{i}_{record['meta'].get('part_name', 'unknown')}"
                    memory_data[key] = record
            
            # Save to memory file
            save_json(MEMORY_FILE, memory_data)
            
        except Exception as e:
            print(f"Error saving data to memory: {e}")
        
    def show_history_record(self, event):
        selection = self.history_tree.selection()
        if not selection:
            return
            
        # Get the selected item
        item = self.history_tree.item(selection[0])
        values = item["values"]
        
        # Find the record
        part_name = values[0]
        datetime_str = values[1]
        
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        for rec in all_records:
            if (rec["meta"].get("part_name") == part_name and 
                rec["meta"].get("datetime") == datetime_str):
                
                # Display the record
                self.history_text.delete("1.0", "end")
                
                # Format the header (same as Results tab)
                part_name = rec['meta'].get('part_name', 'Unknown')
                diameter = rec['meta'].get('diameter', '-') or '-'
                header_text = f"Part: {part_name}    |    Diameter: {diameter} mm\n\n"
                self.history_text.insert("end", header_text)
                
                # Format the details
                details = ""
                
                 # Add table with proper data validation
                if rec["headers"] and rec["data"]:
                    try:
                        # Ensure data and headers have the same number of columns
                        if len(rec["data"]) > 0 and len(rec["headers"]) > 0:
                            # Validate that each row has the correct number of columns
                            valid_data = []
                            for row in rec["data"]:
                                if len(row) == len(rec["headers"]):
                                    valid_data.append(row)
                                else:
                                    # Pad or truncate row to match headers
                                    padded_row = list(row)
                                    while len(padded_row) < len(rec["headers"]):
                                        padded_row.append("-")
                                    if len(padded_row) > len(rec["headers"]):
                                        padded_row = padded_row[:len(rec["headers"])]
                                    valid_data.append(padded_row)
                            
                            if valid_data:
                                tbl = tabulate(
                                    valid_data,
                                    headers=rec["headers"],
                                    tablefmt="github",  # Same format as Results tab
                                    floatfmt=".2f",
                                    numalign="center",
                                    stralign="center",
                                )
                                details += tbl + "\n\n"
                            else:
                                details += "No valid data rows found.\n\n"
                        else:
                            details += "Data structure is empty.\n\n"
                    except Exception as e:
                        details += f"Error formatting table: {str(e)}\n\n"
                        # Fallback: show raw data
                        details += "Raw Data:\n"
                        for i, row in enumerate(rec["data"]):
                            details += f"Row {i+1}: {row}\n"
                        details += "\n"
               
                # Add notes if available
                if rec["meta"].get("notes"):
                   details += f"Notes:\n{rec['meta'].get('notes')}\n\n"
                
                # Add photo info if available
                if rec["meta"].get("photo"):
                    details += f"Photo: {rec['meta'].get('photo')}\n"
                
                self.history_text.insert("end", details)
                break  # Found the record, exit the loop
    
    def history_clear_details(self):
        """Clear the History details display"""
        self.history_text.delete("1.0", "end")
        
    # ---------- DB tab methods ----------
    def db_load_records(self, query=None, filters=None):
        # Clear existing items
        for item in self.db_tree.get_children():
            self.db_tree.delete(item)
        
        # Get records from database
        db_records = search_db_records(query=query, filters=filters)
        
        # Also get records from current session and Excel
        all_records = []
        
        # Add database records
        for record in db_records:
            all_records.append({
                "id": f"DB_{record['id']}",
                "part_name": record["part_name"],
                "diameter": record["diameter"],
                "datetime": record["datetime"],
                "source_file": record["source_file"],
                "type": "database"
            })
        
        # Add current session records
        for i, record in enumerate(self.current_session_records):
            all_records.append({
                "id": f"CS_{i}",
                "part_name": record["meta"].get("part_name", "Unknown"),
                "diameter": record["meta"].get("diameter", "-"),
                "datetime": record["meta"].get("datetime", "Current Session"),
                "source_file": "Current Session",
                "type": "current_session"
            })
        
        # Add Excel records
        for i, record in enumerate(self.excel_records):
            all_records.append({
                "id": f"EX_{i}",
                "part_name": record["meta"].get("part_name", "Unknown"),
                "diameter": record["meta"].get("diameter", "-"),
                "datetime": record["meta"].get("datetime", "Excel Import"),
                "source_file": "Excel Import",
                "type": "excel"
            })
        
        # Apply filters if provided
        if filters:
            filtered_records = []
            for record in all_records:
                include = True
                if "part_name" in filters and filters["part_name"].lower() not in record["part_name"].lower():
                    include = False
                if "diameter" in filters and filters["diameter"] not in str(record["diameter"]):
                    include = False
                if "source_type" in filters and filters["source_type"] != record["type"]:
                    include = False
                if include:
                    filtered_records.append(record)
            all_records = filtered_records
        
        # Insert all records into treeview
        for record in all_records:
            self.db_tree.insert("", "end", values=(
                record["id"],
                record["part_name"],
                record["diameter"],
                record["datetime"],
                record["source_file"]
            ), tags=(record["type"],))
            
    def db_search(self):
        query = self.db_search_var.get()
        self.db_load_records(query=query)
        
    def db_open_filters(self):
        # Create filter dialog
        filter_dialog = ctk.CTkToplevel(self)
        filter_dialog.title("Database Filters")
        filter_dialog.geometry("400x300")
        filter_dialog.resizable(False, False)
        
        # Make dialog appear on top
        filter_dialog.transient(self)
        filter_dialog.grab_set()
        
        # Filter variables
        part_name_var = tk.StringVar()
        diameter_var = tk.StringVar()
        source_type_var = tk.StringVar(value="all")
        clear_filters_var = tk.BooleanVar(value=False)
        
        # Create filter form
        ctk.CTkLabel(filter_dialog, text="Part Name:", font=ctk.CTkFont(size=14, weight="bold")).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(filter_dialog, textvariable=part_name_var, placeholder_text="Enter part name to search").grid(row=0, column=1, sticky="ew", padx=10, pady=5)
        
        ctk.CTkLabel(filter_dialog, text="Diameter:", font=ctk.CTkFont(size=14, weight="bold")).grid(row=1, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(filter_dialog, textvariable=diameter_var, placeholder_text="Enter diameter value").grid(row=1, column=1, sticky="ew", padx=10, pady=5)
        
        ctk.CTkLabel(filter_dialog, text="Source Type:", font=ctk.CTkFont(size=14, weight="bold")).grid(row=2, column=0, sticky="w", padx=10, pady=5)
        source_types = ["all", "database", "current_session", "excel"]
        source_combo = ctk.CTkComboBox(filter_dialog, variable=source_type_var, values=source_types, width=200)
        source_combo.grid(row=2, column=1, sticky="ew", padx=10, pady=5)
        
        # Clear filters checkbox
        ctk.CTkCheckBox(filter_dialog, text="Clear all filters", variable=clear_filters_var, 
                       font=ctk.CTkFont(size=12)).grid(row=3, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        # Buttons
        button_frame = ctk.CTkFrame(filter_dialog)
        button_frame.grid(row=5, column=0, columnspan=2, pady=10)
        
        def apply_filters():
            if clear_filters_var.get():
                # Clear all filters and show all records
                self.db_load_records()
                filter_dialog.destroy()
                return
                
            filters = {}
            if part_name_var.get():
                filters["part_name"] = part_name_var.get()
            if diameter_var.get():
                filters["diameter"] = diameter_var.get()
            if source_type_var.get() != "all":
                filters["source_type"] = source_type_var.get()
                
            self.db_load_records(filters=filters)
            filter_dialog.destroy()
            
        ctk.CTkButton(button_frame, text="Apply", command=apply_filters).pack(side="left", padx=5)
        ctk.CTkButton(button_frame, text="Cancel", command=filter_dialog.destroy).pack(side="left", padx=5)
        
        filter_dialog.grid_columnconfigure(1, weight=1)
        
    def db_new_database(self):
        new_db_path = create_new_database()
        if new_db_path:
            messagebox.showinfo("New Database", f"New database created at:\n{new_db_path}")
            self.db_load_records()
            
    def db_show_details(self, event):
        selection = self.db_tree.selection()
        if not selection:
            return
            
        # Get the selected item
        item = self.db_tree.item(selection[0])
        values = item["values"]
        tags = item["tags"]
        
        # Get the record ID and type
        record_id = values[0]
        record_type = tags[0] if tags else "unknown"
        
        # Get the appropriate record based on type
        record = None
        if record_type == "database":
            # Extract numeric ID from "DB_X" format
            try:
                db_id = int(record_id.split("_")[1])
                records = search_db_records(filters={'id': db_id})
                if records:
                    record = records[0]
            except:
                pass
        elif record_type == "current_session":
            # Extract index from "CS_X" format
            try:
                cs_index = int(record_id.split("_")[1])
                if cs_index < len(self.current_session_records):
                    record = self.current_session_records[cs_index]
            except:
                pass
        elif record_type == "excel":
            # Extract index from "EX_X" format
            try:
                ex_index = int(record_id.split("_")[1])
                if ex_index < len(self.excel_records):
                    record = self.excel_records[ex_index]
            except:
                pass
        
        if not record:
            return
        
        # Display the record
        self.db_details_text.delete("1.0", "end")
        
        # Format the header (same as Results tab)
        if record_type == "database":
            part_name = record['part_name']
            diameter = record['diameter']
        else:
            part_name = record['meta'].get('part_name', 'Unknown')
            diameter = record['meta'].get('diameter', '-')
        
        header_text = f"Part: {part_name}    |    Diameter: {diameter} mm\n\n"
        self.db_details_text.insert("end", header_text)
        
        # Format the details with better structure
        details = f"📋 RECORD DETAILS\n"
        details += f"{'='*50}\n\n"
        
        if record_type == "database":
            details += f"🆔 ID: {record['id']}\n"
            details += f"🔧 Part Name: {record['part_name']}\n"
            details += f"📏 Diameter: {record['diameter']} mm\n"
            details += f"📅 Date/Time: {record['datetime']}\n"
            details += f"📁 Source File: {record['source_file']}\n"
            details += f"📝 Notes: {record['notes'] if record['notes'] else 'No notes'}\n"
            details += f"🖼️ Photo: {record['photo_path'] if record['photo_path'] else 'No photo'}\n\n"
        else:
            # For current session and Excel records
            details += f"🆔 ID: {record_id}\n"
            details += f"🔧 Part Name: {record['meta'].get('part_name', 'Unknown')}\n"
            details += f"📏 Diameter: {record['meta'].get('diameter', '-')} mm\n"
            details += f"📅 Date/Time: {record['meta'].get('datetime', 'Unknown')}\n"
            details += f"📁 Source: {record_type.replace('_', ' ').title()}\n"
            details += f"📝 Notes: {record['meta'].get('notes', 'No notes')}\n"
            details += f"🖼️ Photo: {record['meta'].get('photo', 'No photo')}\n\n"
        
        # Add table with better formatting and data validation
        if record_type == "database":
            # Database record structure
            if record['headers'] and record['data']:
                details += f"📊 MEASUREMENT DATA\n"
                details += f"{'='*50}\n\n"
                
                try:
                    # Ensure data and headers have the same number of columns
                    if len(record['data']) > 0 and len(record['headers']) > 0:
                        # Validate that each row has the correct number of columns
                        valid_data = []
                        for row in record['data']:
                            if len(row) == len(record['headers']):
                                valid_data.append(row)
                            else:
                                # Pad or truncate row to match headers
                                padded_row = list(row)
                                while len(padded_row) < len(record['headers']):
                                    padded_row.append("-")
                                if len(padded_row) > len(record['headers']):
                                    padded_row = padded_row[:len(record['headers'])]
                                valid_data.append(padded_row)
                        
                        if valid_data:
                            # Create a more readable table format
                            tbl = tabulate(
                                valid_data,
                                headers=record['headers'],
                                tablefmt="github",  # Same format as Results tab
                                floatfmt=".2f",
                                numalign="center",
                                stralign="center",
                            )
                            details += tbl
                        else:
                            details += "No valid data rows found.\n"
                    else:
                        details += "Data structure is empty.\n"
                except Exception as e:
                    details += f"Error formatting table: {e}\n"
                    # Fallback: show raw data
                    details += "Raw Data:\n"
                    for i, row in enumerate(record['data']):
                        details += f"Row {i+1}: {row}\n"
            else:
                details += "No measurement data available.\n"
        else:
            # Current session and Excel record structure
            if record.get('headers') and record.get('data'):
                details += f"📊 MEASUREMENT DATA\n"
                details += f"{'='*50}\n\n"
                
                try:
                    # Ensure data and headers have the same number of columns
                    if len(record['data']) > 0 and len(record['headers']) > 0:
                        # Validate that each row has the correct number of columns
                        valid_data = []
                        for row in record['data']:
                            if len(row) == len(record['headers']):
                                valid_data.append(row)
                            else:
                                # Pad or truncate row to match headers
                                padded_row = list(row)
                                while len(padded_row) < len(record['headers']):
                                    padded_row.append("-")
                                if len(padded_row) > len(record['headers']):
                                    padded_row = padded_row[:len(record['headers'])]
                                valid_data.append(padded_row)
                        
                        if valid_data:
                            # Create a more readable table format
                            tbl = tabulate(
                                valid_data,
                                headers=record['headers'],
                                tablefmt="github",  # Same format as Results tab
                                floatfmt=".2f",
                                numalign="center",
                                stralign="center",
                            )
                            details += tbl
                        else:
                            details += "No valid data rows found.\n"
                    else:
                        details += "Data structure is empty.\n"
                except Exception as e:
                    details += f"Error formatting table: {e}\n"
                    # Fallback: show raw data
                    details += "Raw Data:\n"
                    for i, row in enumerate(record['data']):
                        details += f"Row {i+1}: {row}\n"
            else:
                details += "No measurement data available.\n"
        
        self.db_details_text.insert("end", details)
        
        # Store the current selection to prevent issues
        self.current_db_selection = record_id
        
        # Show the details frame
        self.db_details_frame.pack_info()  # Check if it's visible
        if not self.db_details_frame.winfo_viewable():
            self.db_details_frame.pack(fill="both", expand=True)
    
    def db_clear_details(self):
        """Clear the DB details display and hide the details frame"""
        self.db_details_text.delete("1.0", "end")
        self.current_db_selection = None
        # Hide the details frame
        self.db_details_frame.pack_forget()
        
    # ---------- Charts tab methods ----------
    def generate_chart(self):
        # Get selected parts
        selected_indices = self.parts_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("No Selection", "Please select at least one part for charting.")
            return
            
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        if not all_records:
            messagebox.showwarning("No Data", "No data available for chart generation.")
            return
            
        # Filter records based on selection
        selected_records = []
        for i in selected_indices:
            part_name = self.parts_listbox.get(i)
            for record in all_records:
                if (isinstance(record, dict) and "meta" in record and 
                    record["meta"].get("part_name") == part_name):
                    selected_records.append(record)
                    break
        
        if not selected_records:
            messagebox.showwarning("No Data", "No data found for selected parts.")
            return
            
        # Clear previous chart
        if self.chart_canvas:
            self.chart_canvas.get_tk_widget().destroy()
            
        # Get chart type and data type
        chart_type = self.chart_type_var.get()
        data_type = self.chart_data_var.get()
        
        # Prepare data
        all_data = []
        part_names = []
        
        for record in selected_records:
            part_names.append(record["meta"]["part_name"])
            
            # Extract data based on type
            if data_type == "thickness":
                # THme values
                if "THme (mm)" in record["headers"]:
                    idx = record["headers"].index("THme (mm)")
                    data = [row[idx] for row in record["data"]]
                else:
                    data = []
            elif data_type == "coating":
                # COth values
                if "COth (mm)" in record["headers"]:
                    idx = record["headers"].index("COth (mm)")
                    data = [row[idx] for row in record["data"]]
                else:
                    data = []
            elif data_type == "corrosion":
                # CR values if available
                if "CR (mm)" in record["headers"]:
                    idx = record["headers"].index("CR (mm)")
                    data = [row[idx] for row in record["data"]]
                else:
                    data = []
            elif data_type == "all":
                # Combine all available data
                data = []
                if "THme (mm)" in record["headers"]:
                    idx = record["headers"].index("THme (mm)")
                    data.extend([row[idx] for row in record["data"]])
                if "COth (mm)" in record["headers"]:
                    idx = record["headers"].index("COth (mm)")
                    data.extend([row[idx] for row in record["data"]])
                if "CR (mm)" in record["headers"]:
                    idx = record["headers"].index("CR (mm)")
                    data.extend([row[idx] for row in record["data"]])
            else:
                data = []
                
            all_data.append(data)
        
        # Create figure with proper size and Arabic font support
        try:
            # Try to set Arabic font support with proper text direction
            plt.rcParams['font.family'] = ['DejaVu Sans', 'Arial Unicode MS', 'Arial', 'sans-serif']
            plt.rcParams['font.size'] = 12
        except:
            # Fallback to default fonts
            plt.rcParams['font.family'] = ['sans-serif']
            plt.rcParams['font.size'] = 12
        
        # Use smaller figure size to prevent exaggeration
        self.chart_figure = plt.figure(figsize=(10, 6), dpi=80)
        ax = self.chart_figure.add_subplot(111)
        
        # Generate chart based on type
        if chart_type == "line":
            for i, data in enumerate(all_data):
                if data:
                    # Process part name for legend
                    label = self.process_arabic_text(part_names[i])
                    ax.plot(data, label=label, linewidth=2, marker='o', markersize=4)
            # Handle Arabic text with proper RTL display
            xlabel_text = "Measurement Point | " + self.process_arabic_text("نقطة القياس")
            ylabel_text = f"{data_type.capitalize()} (mm) | " + self.process_arabic_text(f"{data_type.capitalize()} (مم)")
            # Include part names in title with proper RTL formatting
            parts_str = " - ".join([self.process_arabic_text(name) for name in part_names])
            title_text = f"{data_type.capitalize()} Measurements | " + self.process_arabic_text(f"قياسات {parts_str}")
            
            ax.set_xlabel(xlabel_text, fontsize=14, fontweight='bold')
            ax.set_ylabel(ylabel_text, fontsize=14, fontweight='bold')
            ax.set_title(title_text, fontsize=16, fontweight='bold')
            ax.legend(prop={'size': 12})
            ax.grid(True, alpha=0.3)
            
        elif chart_type == "bar":
            # For bar chart, we'll show average values per part
            avg_values = [sum(data)/len(data) if data else 0 for data in all_data]
            # Process part names for x-axis
            arabic_part_names = [self.process_arabic_text(name) for name in part_names]
            bars = ax.bar(arabic_part_names, avg_values, color='skyblue', edgecolor='navy', linewidth=1)
            # Handle Arabic text with proper RTL display
            xlabel_text = "Part Name | " + self.process_arabic_text("اسم الجزء")
            ylabel_text = f"Average {data_type.capitalize()} (mm) | " + self.process_arabic_text(f"متوسط {data_type.capitalize()} (مم)")
            title_text = f"Average {data_type.capitalize()} by Part | " + self.process_arabic_text(f"متوسط {data_type.capitalize()} حسب الجزء")
            
            ax.set_xlabel(xlabel_text, fontsize=14, fontweight='bold')
            ax.set_ylabel(ylabel_text, fontsize=14, fontweight='bold')
            ax.set_title(title_text, fontsize=16, fontweight='bold')
            plt.xticks(rotation=45, ha='right')
            
            # Add value labels on bars
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                       f'{height:.2f}', ha='center', va='bottom', fontweight='bold')
            
        elif chart_type == "scatter":
            # For scatter, we'll show all points with different colors per part
            colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray']
            for i, data in enumerate(all_data):
                if data:
                    x = list(range(1, len(data)+1))
                    color = colors[i % len(colors)]
                    # Process part name for legend
                    label = self.process_arabic_text(part_names[i])
                    ax.scatter(x, data, label=label, color=color, s=50, alpha=0.7)
            # Add trend lines for each part
            for i, data in enumerate(all_data):
                if data:
                    x = list(range(1, len(data)+1))
                    z = np.polyfit(x, data, 1)
                    p = np.poly1d(z)
                    color = colors[i % len(colors)]
                    ax.plot(x, p(x), '--', color=color, alpha=0.5)
            # Process Arabic text properly to prevent reversal
            xlabel_text = self.process_arabic_text("نقطة القياس")
            ylabel_text = self.process_arabic_text(f"{data_type.capitalize()} (مم)")
            # Include part names in title
            parts_str = " و ".join([self.process_arabic_text(name) for name in part_names])
            title_text = self.process_arabic_text(f"قياسات {data_type.capitalize()} - {parts_str}")
            
            ax.set_xlabel(xlabel_text, fontsize=14, fontweight='bold')
            ax.set_ylabel(ylabel_text, fontsize=14, fontweight='bold')
            ax.set_title(title_text, fontsize=16, fontweight='bold')
            ax.legend(prop={'size': 12})
            ax.grid(True, alpha=0.3)
            
        elif chart_type == "pie":
            # For pie chart, we'll show distribution of values
            # This is more meaningful for corrosion rates
            if data_type == "corrosion":
                # Count dangerous vs safe corrosion rates
                dangerous = 0
                safe = 0
                
                for data in all_data:
                    for val in data:
                        if val > 1.0:
                            dangerous += 1
                        else:
                            safe += 1
                            
                if dangerous + safe > 0:
                    # Process Arabic text properly to prevent reversal
                    labels = [self.process_arabic_text("خطر (>1.0 مم)"), self.process_arabic_text("آمن (≤1.0 مم)")]
                    colors = ['#ff6b6b', '#51cf66']
                    ax.pie([dangerous, safe], labels=labels, autopct='%1.1f%%', 
                           colors=colors, startangle=90, textprops={'fontsize': 12})
                    title_text = self.process_arabic_text("توزيع معدل التآكل")
                    ax.set_title(title_text, fontsize=16, fontweight='bold')
                else:
                    no_data_text = self.process_arabic_text("لا توجد بيانات تآكل متاحة")
                    ax.text(0.5, 0.5, no_data_text, ha='center', va='center', 
                           fontsize=14, fontweight='bold')
            else:
                not_suitable_text = self.process_arabic_text(f"مخطط دائري غير مناسب لبيانات {data_type}")
                ax.text(0.5, 0.5, not_suitable_text, ha='center', va='center', 
                       fontsize=14, fontweight='bold')
            
        elif chart_type == "box":
            # Box plot for distribution analysis
            if all_data and any(data for data in all_data):
                # Filter out empty data
                valid_data = [data for data in all_data if data]
                valid_names = [part_names[i] for i, data in enumerate(all_data) if data]
                # Process part names for labels
                arabic_valid_names = [self.process_arabic_text(name) for name in valid_names]
                
                if valid_data:
                    bp = ax.boxplot(valid_data, labels=arabic_valid_names, patch_artist=True)
                    # Color the boxes
                    colors = ['lightblue', 'lightgreen', 'lightcoral', 'lightyellow', 'lightpink']
                    for patch, color in zip(bp['boxes'], colors):
                        patch.set_facecolor(color)
                        patch.set_alpha(0.7)
                    
                    # Process Arabic text properly to prevent reversal
                    xlabel_text = self.process_arabic_text("اسم الجزء")
                    ylabel_text = self.process_arabic_text(f"{data_type.capitalize()} (مم)")
                    # Include part names in title
                    parts_str = " و ".join([self.process_arabic_text(name) for name in valid_names])
                    title_text = self.process_arabic_text(f"توزيع {data_type.capitalize()} - {parts_str}")                    
                    ax.set_xlabel(xlabel_text, fontsize=14, fontweight='bold')
                    ax.set_ylabel(ylabel_text, fontsize=14, fontweight='bold')
                    ax.set_title(title_text, fontsize=16, fontweight='bold')
                    plt.xticks(rotation=45, ha='right')
                    ax.grid(True, alpha=0.3)
                else:
                    no_valid_text = self.process_arabic_text("لا توجد بيانات صالحة للمخطط")
                    ax.text(0.5, 0.5, no_valid_text, ha='center', va='center', 
                           fontsize=14, fontweight='bold')
            else:
                no_data_text = self.process_arabic_text("لا توجد بيانات متاحة")
                ax.text(0.5, 0.5, no_data_text, ha='center', va='center', 
                       fontsize=14, fontweight='bold')
                
        elif chart_type == "histogram":
            # Histogram for frequency distribution
            if all_data and any(data for data in all_data):
                # Combine all data for histogram
                combined_data = []
                for data in all_data:
                    combined_data.extend(data)
                
                if combined_data:
                    ax.hist(combined_data, bins=20, alpha=0.7, color='skyblue', edgecolor='navy')
                    # Process Arabic text properly to prevent reversal
                    xlabel_text = self.process_arabic_text(f"{data_type.capitalize()} (مم)")
                    ylabel_text = self.process_arabic_text("التكرار")
                    # Include part names in title
                    parts_str = " و ".join([self.process_arabic_text(name) for name in part_names])
                    title_text = self.process_arabic_text(f"توزيع قيم {data_type.capitalize()} - {parts_str}")
                    
                    ax.set_xlabel(xlabel_text, fontsize=14, fontweight='bold')
                    ax.set_ylabel(ylabel_text, fontsize=14, fontweight='bold')
                    ax.set_title(title_text, fontsize=16, fontweight='bold')
                    ax.grid(True, alpha=0.3)
                else:
                    no_valid_text = self.process_arabic_text("لا توجد بيانات صالحة للمخطط")
                    ax.text(0.5, 0.5, no_valid_text, ha='center', va='center', 
                           fontsize=14, fontweight='bold')
            else:
                no_data_text = self.process_arabic_text("لا توجد بيانات متاحة")
                ax.text(0.5, 0.5, no_data_text, ha='center', va='center', 
                       fontsize=14, fontweight='bold')
        
        # Adjust layout
        plt.tight_layout()
        
        # Embed in tkinter
        self.chart_canvas = FigureCanvasTkAgg(self.chart_figure, master=self.chart_frame)
        self.chart_canvas.draw()
        self.chart_canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Enable download button
        self.download_chart_btn.configure(state="normal")
        
    def add_general_notes(self):
        # Create dialog for general notes
        notes_dialog = ctk.CTkToplevel(self)
        notes_dialog.title("إضافة ملاحظات عامة")
        notes_dialog.geometry("500x400")
        
        # Make dialog appear on top
        notes_dialog.transient(self)
        notes_dialog.grab_set()
        
        # Create notes text area
        notes_frame = ctk.CTkFrame(notes_dialog)
        notes_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        notes_label = ctk.CTkLabel(notes_frame, text="الملاحظات العامة:", font=ctk.CTkFont(size=14, weight="bold"))
        notes_label.pack(pady=(5,5), anchor="w")
        
        notes_text = ctk.CTkTextbox(
            notes_frame,
            wrap="word",
            height=300,
            fg_color=self.colors["entry"],
            text_color=self.colors["text"]
        )
        notes_text.pack(fill="both", expand=True, pady=5)
        
        # Load existing notes if any
        path = settings.get("last_excel", "")
        if path and os.path.isfile(path):
            try:
                wb = load_workbook(path)
                if "GeneralNotes" in wb.sheetnames:
                    ws = wb["GeneralNotes"]
                    notes = []
                    for row in ws.iter_rows(min_row=1, values_only=True):
                        if row[0]:  # if cell is not empty
                            notes.append(str(row[0]))
                    notes_text.insert("1.0", "\n".join(notes))
            except Exception as e:
                print(f"Error loading general notes: {e}")
        
        def save_notes():
            path = settings.get("last_excel", "")
            if not path:
                messagebox.showwarning("No Excel File", "Please open an Excel file first.")
                return
                
            try:
                wb = load_workbook(path)
                ws = wb["Results"] if "Results" in wb.sheetnames else wb.create_sheet("Results")
                
                # Find last row with content
                max_row = ws.max_row
                while max_row > 0 and not any(ws.cell(row=max_row, column=col).value for col in range(1, ws.max_column + 1)):
                    max_row -= 1
                
                # Remove existing notes section if found
                while max_row > 0 and str(ws.cell(row=max_row, column=1).value).startswith("General Notes:"):
                    # Delete the merged cells and content
                    for row in range(max_row, 0, -1):
                        if not str(ws.cell(row=row, column=1).value).startswith("General Notes:"):
                            max_row = row
                            break
                        # Unmerge if merged
                        for merge in ws.merged_cells.ranges:
                            if merge.min_row == row:
                                ws.unmerge_cells(start_row=row, start_column=1, end_row=row, end_column=ws.max_column)
                        # Clear the row
                        for col in range(1, ws.max_column + 1):
                            ws.cell(row=row, column=col).value = None
                
                # Add empty row after data
                max_row += 2
                
                # Get notes text
                notes = notes_text.get("1.0", "end-1c")
                
                # Write notes header
                header_cell = ws.cell(row=max_row, column=1, value="General Notes:")
                header_cell.font = Font(bold=True)
                ws.merge_cells(start_row=max_row, start_column=1, end_row=max_row, end_column=ws.max_column)
                max_row += 1
                
                # Write notes line by line
                for line in notes.split("\n"):
                    ws.merge_cells(start_row=max_row, start_column=1, end_row=max_row, end_column=ws.max_column)
                    cell = ws.cell(row=max_row, column=1, value=line)
                    cell.alignment = Alignment(horizontal='left', vertical='center', wrap_text=True)
                    max_row += 1
                
                # Save workbook
                wb.save(path)
                messagebox.showinfo("Success", "General notes saved successfully.")
                notes_dialog.destroy()
                
            except Exception as e:
                messagebox.showerror("Error", f"Error saving notes: {str(e)}")
        
        # Buttons
        btn_frame = ctk.CTkFrame(notes_dialog)
        btn_frame.pack(fill="x", pady=10)
        
        save_btn = ctk.CTkButton(btn_frame, text="حفظ الملاحظات", command=save_notes)
        save_btn.pack(side="left", padx=5)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="إلغاء", command=notes_dialog.destroy)
        cancel_btn.pack(side="left", padx=5)

    def download_chart(self):
        if not self.chart_figure:
            return
            
        # Ask for save location
        path = filedialog.asksaveasfilename(
            defaultextension=".png",
            filetypes=[("PNG files", "*.png"), ("All files", "*.*")],
            initialfile=f"{self.chart_data_var.get()}_chart.png"
        )
        
        if path:
            self.chart_figure.savefig(path, dpi=300, bbox_inches='tight')
            messagebox.showinfo("Download", f"Chart saved to:\n{path}")
            
    # ---------- Analysis tab methods ----------
    def get_general_notes(self):
        """Read general notes from Results sheet"""
        notes = []
        path = settings.get("last_excel", "")
        if path and os.path.isfile(path):
            try:
                wb = load_workbook(path)
                if "Results" in wb.sheetnames:
                    ws = wb["Results"]
                    found_notes = False
                    for row in ws.iter_rows(values_only=True):
                        if row[0] == "General Notes:":
                            found_notes = True
                            continue
                        if found_notes and row[0]:  # if cell is not empty
                            notes.append(str(row[0]))
            except Exception as e:
                print(f"Error reading general notes: {e}")
        return notes

    def analyze_station(self):
        # Get all records (both from current session and Excel)
        all_records = self.current_session_records + self.excel_records
        
        if not all_records:
            messagebox.showwarning("No Data", "No data available for analysis.")
            return
            
        # Get analysis type
        analysis_type = self.analysis_type_var.get()
        
        # Clear previous analysis
        self.analysis_text.delete("1.0", "end")
        
        # Prepare data
        all_thickness = []
        all_coating = []
        all_corrosion = []
        all_diameters = []
        part_names = []
        
        for record in all_records:
            part_names.append(record["meta"]["part_name"])
            
            # Get diameter
            diameter = record["meta"].get("diameter")
            if diameter:
                try:
                    all_diameters.append(float(diameter))
                except:
                    pass
            
            # Extract data
            thickness_data = []
            coating_data = []
            corrosion_data = []
            
            if "THme (mm)" in record["headers"]:
                idx = record["headers"].index("THme (mm)")
                thickness_data = [row[idx] for row in record["data"]]
                
            if "COth (mm)" in record["headers"]:
                idx = record["headers"].index("COth (mm)")
                coating_data = [row[idx] for row in record["data"]]
                
            if "CR (mm)" in record["headers"]:
                idx = record["headers"].index("CR (mm)")
                corrosion_data = [row[idx] for row in record["data"]]
                
            all_thickness.extend(thickness_data)
            all_coating.extend(coating_data)
            all_corrosion.extend(corrosion_data)
        
        # Generate analysis based on type
        analysis = ""
        
        if analysis_type == "basic":
            analysis = "=== STATION ANALYSIS SUMMARY ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n"
            
            if all_diameters:
                analysis += f"Average Diameter: {sum(all_diameters)/len(all_diameters):.2f} mm\n"
                
            if all_thickness:
                analysis += f"Average Thickness: {sum(all_thickness)/len(all_thickness):.2f} mm\n"
                
            if all_coating:
                analysis += f"Average Coating: {sum(all_coating)/len(all_coating):.2f} mm\n"
                
            if all_corrosion:
                dangerous = sum(1 for cr in all_corrosion if cr > 1.0)
                analysis += f"Dangerous Corrosion Rates: {dangerous} out of {len(all_corrosion)} measurements\n"
            
            # Add general notes if available
            general_notes = self.get_general_notes()
            if general_notes:
                analysis += "\n=== الملاحظات العامة ===\n"
                analysis += "\n".join(general_notes) + "\n"
                
            analysis += "\nAnalysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
        elif analysis_type == "statistical":
            analysis = "=== DETAILED STATION ANALYSIS ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n\n"
            
            # Diameter analysis
            if all_diameters:
                analysis += "=== DIAMETER ANALYSIS ===\n"
                analysis += f"Minimum Diameter: {min(all_diameters):.2f} mm\n"
                analysis += f"Maximum Diameter: {max(all_diameters):.2f} mm\n"
                analysis += f"Average Diameter: {sum(all_diameters)/len(all_diameters):.2f} mm\n"
                analysis += f"Diameter Range: {max(all_diameters) - min(all_diameters):.2f} mm\n\n"
            
            # Thickness analysis
            if all_thickness:
                analysis += "=== THICKNESS ANALYSIS ===\n"
                analysis += f"Minimum Thickness: {min(all_thickness):.2f} mm\n"
                analysis += f"Maximum Thickness: {max(all_thickness):.2f} mm\n"
                analysis += f"Average Thickness: {sum(all_thickness)/len(all_thickness):.2f} mm\n"
                analysis += f"Thickness Range: {max(all_thickness) - min(all_thickness):.2f} mm\n\n"
            
            # Coating analysis
            if all_coating:
                analysis += "=== COATING ANALYSIS ===\n"
                analysis += f"Minimum Coating: {min(all_coating):.2f} mm\n"
                analysis += f"Maximum Coating: {max(all_coating):.2f} mm\n"
                analysis += f"Average Coating: {sum(all_coating)/len(all_coating):.2f} mm\n"
                analysis += f"Coating Range: {max(all_coating) - min(all_coating):.2f} mm\n\n"
            
            # Corrosion analysis
            if all_corrosion:
                analysis += "=== CORROSION ANALYSIS ===\n"
                analysis += f"Minimum Corrosion Rate: {min(all_corrosion):.2f} mm\n"
                analysis += f"Maximum Corrosion Rate: {max(all_corrosion):.2f} mm\n"
                analysis += f"Average Corrosion Rate: {sum(all_corrosion)/len(all_corrosion):.2f} mm\n"
                
                dangerous = sum(1 for cr in all_corrosion if cr > 1.0)
                safe = len(all_corrosion) - dangerous
                analysis += f"Dangerous Corrosion Rates (>1.0 mm): {dangerous} measurements ({dangerous/len(all_corrosion)*100:.1f}%)\n"
                analysis += f"Safe Corrosion Rates (≤1.0 mm): {safe} measurements ({safe/len(all_corrosion)*100:.1f}%)\n\n"
                
                # Parts with dangerous corrosion
                dangerous_parts = []
                for i, record in enumerate(all_records):
                    if "CR (mm)" in record["headers"]:
                        idx = record["headers"].index("CR (mm)")
                        corrosion_data = [row[idx] for row in record["data"]]
                        if any(cr > 1.0 for cr in corrosion_data):
                            dangerous_parts.append(part_names[i])
                            
                if dangerous_parts:
                    analysis += "Parts with Dangerous Corrosion Rates:\n"
                    for part in dangerous_parts:
                        analysis += f"- {part}\n"
                    analysis += "\n"
            
            # Thickness vs Coating comparison
            if all_thickness and all_coating and len(all_thickness) == len(all_coating):
                analysis += "=== THICKNESS VS COATING COMPARISON ===\n"
                
                # Calculate ratio
                ratios = [t/c if c > 0 else 0 for t, c in zip(all_thickness, all_coating)]
                analysis += f"Average Thickness/Coating Ratio: {sum(ratios)/len(ratios):.2f}\n"
                
                # Find parts with unusual ratios
                unusual_parts = []
                for i, record in enumerate(all_records):
                    if ("THme (mm)" in record["headers"] and 
                        "COth (mm)" in record["headers"]):
                        t_idx = record["headers"].index("THme (mm)")
                        c_idx = record["headers"].index("COth (mm)")
                        
                        thickness_data = [row[t_idx] for row in record["data"]]
                        coating_data = [row[c_idx] for row in record["data"]]
                        
                        if len(thickness_data) == len(coating_data):
                            part_ratios = [t/c if c > 0 else 0 for t, c in zip(thickness_data, coating_data)]
                            avg_ratio = sum(part_ratios) / len(part_ratios)
                            
                            # Consider unusual if ratio is outside 0.5-2.0 range
                            if avg_ratio < 0.5 or avg_ratio > 2.0:
                                unusual_parts.append((part_names[i], avg_ratio))
                
                if unusual_parts:
                    analysis += "Parts with Unusual Thickness/Coating Ratios:\n"
                    for part, ratio in unusual_parts:
                        analysis += f"- {part}: {ratio:.2f}\n"
                    analysis += "\n"
            
            analysis += "Analysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
        elif analysis_type == "trend":
            analysis = "=== TREND ANALYSIS ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n\n"
            
            # Time-based trend analysis
            if len(all_records) > 1:
                analysis += "=== TIME-BASED TRENDS ===\n"
                
                # Sort records by datetime
                sorted_records = sorted(all_records, key=lambda x: x["meta"].get("datetime", ""))
                
                # Analyze trends over time
                thickness_trends = []
                coating_trends = []
                corrosion_trends = []
                
                for record in sorted_records:
                    if "THme (mm)" in record["headers"]:
                        idx = record["headers"].index("THme (mm)")
                        thickness_data = [row[idx] for row in record["data"]]
                        if thickness_data:
                            thickness_trends.append(sum(thickness_data) / len(thickness_data))
                            thickness_trends.append(sum(thickness_data) / len(thickness_data))
                    
                    if "COth (mm)" in record["headers"]:
                        idx = record["headers"].index("COth (mm)")
                        coating_data = [row[idx] for row in record["data"]]
                        if coating_data:
                            coating_trends.append(sum(coating_data) / len(coating_data))
                    
                    if "CR (mm)" in record["headers"]:
                        idx = record["headers"].index("CR (mm)")
                        corrosion_data = [row[idx] for row in record["data"]]
                        if corrosion_data:
                            corrosion_trends.append(sum(corrosion_data) / len(corrosion_data))
                
                # Calculate trend slopes
                if len(thickness_trends) > 1:
                    thickness_slope = (thickness_trends[-1] - thickness_trends[0]) / len(thickness_trends)
                    analysis += f"Thickness Trend: {'Increasing' if thickness_slope > 0 else 'Decreasing'} ({thickness_slope:.3f} mm/measurement)\n"
                
                if len(coating_trends) > 1:
                    coating_slope = (coating_trends[-1] - coating_trends[0]) / len(coating_trends)
                    analysis += f"Coating Trend: {'Increasing' if coating_slope > 0 else 'Decreasing'} ({coating_slope:.3f} mm/measurement)\n"
                
                if len(corrosion_trends) > 1:
                    corrosion_slope = (corrosion_trends[-1] - corrosion_trends[0]) / len(corrosion_trends)
                    analysis += f"Corrosion Trend: {'Increasing' if corrosion_slope > 0 else 'Decreasing'} ({corrosion_slope:.3f} mm/measurement)\n"
                    
                    if corrosion_slope > 0.1:
                        analysis += "⚠️ WARNING: Corrosion rate is increasing significantly!\n"
            
            analysis += "\nAnalysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
        elif analysis_type == "correlation":
            analysis = "=== CORRELATION ANALYSIS ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n\n"
            
            # Analyze correlations between different measurements
            if all_thickness and all_coating and len(all_thickness) == len(all_coating):
                # Calculate correlation coefficient
                correlation = np.corrcoef(all_thickness, all_coating)[0, 1]
                analysis += f"Thickness vs Coating Correlation: {correlation:.3f}\n"
                
                if abs(correlation) > 0.7:
                    analysis += "Strong correlation detected\n"
                elif abs(correlation) > 0.3:
                    analysis += "Moderate correlation detected\n"
                else:
                    analysis += "Weak correlation detected\n"
            
            if all_thickness and all_corrosion and len(all_thickness) == len(all_corrosion):
                correlation = np.corrcoef(all_thickness, all_corrosion)[0, 1]
                analysis += f"Thickness vs Corrosion Correlation: {correlation:.3f}\n"
                
                if correlation < -0.5:
                    analysis += "⚠️ Strong negative correlation: Thinner parts show higher corrosion!\n"
            
            if all_coating and all_corrosion and len(all_coating) == len(all_corrosion):
                correlation = np.corrcoef(all_coating, all_corrosion)[0, 1]
                analysis += f"Coating vs Corrosion Correlation: {correlation:.3f}\n"
                
                if correlation < -0.5:
                    analysis += "⚠️ Strong negative correlation: Thinner coating shows higher corrosion!\n"
            
            analysis += "\nAnalysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
        elif analysis_type == "machine_learning":
            analysis = "=== MACHINE LEARNING ANALYSIS ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n\n"
            
            try:
                # Import scikit-learn for advanced analysis
                from sklearn.cluster import KMeans
                from sklearn.preprocessing import StandardScaler
                from sklearn.decomposition import PCA
                
                # Prepare data for clustering
                ml_data = []
                valid_indices = []
                
                for i, record in enumerate(all_records):
                    if ("THme (mm)" in record["headers"] and 
                        "COth (mm)" in record["headers"] and
                        "CR (mm)" in record["headers"]):
                        
                        t_idx = record["headers"].index("THme (mm)")
                        c_idx = record["headers"].index("COth (mm)")
                        cr_idx = record["headers"].index("CR (mm)")
                        
                        thickness_data = [row[t_idx] for row in record["data"]]
                        coating_data = [row[c_idx] for row in record["data"]]
                        corrosion_data = [row[cr_idx] for row in record["data"]]
                        
                        if len(thickness_data) == len(coating_data) == len(corrosion_data):
                            for j in range(len(thickness_data)):
                                ml_data.append([thickness_data[j], coating_data[j], corrosion_data[j]])
                                valid_indices.append(i)
                
                if len(ml_data) > 3:
                    # Standardize data
                    scaler = StandardScaler()
                    ml_data_scaled = scaler.fit_transform(ml_data)
                    
                    # K-means clustering
                    n_clusters = min(3, len(ml_data) // 2)
                    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
                    clusters = kmeans.fit_predict(ml_data_scaled)
                    
                    analysis += f"=== CLUSTERING ANALYSIS ===\n"
                    analysis += f"Data points clustered into {n_clusters} groups\n\n"
                    
                    for cluster_id in range(n_clusters):
                        cluster_points = [ml_data[i] for i, c in enumerate(clusters) if c == cluster_id]
                        cluster_parts = [valid_indices[i] for i, c in enumerate(clusters) if c == cluster_id]
                        
                        if cluster_points:
                            avg_thickness = sum(p[0] for p in cluster_points) / len(cluster_points)
                            avg_coating = sum(p[1] for p in cluster_points) / len(cluster_points)
                            avg_corrosion = sum(p[2] for p in cluster_points) / len(cluster_points)
                            
                            analysis += f"Cluster {cluster_id + 1}:\n"
                            analysis += f"  Average Thickness: {avg_thickness:.2f} mm\n"
                            analysis += f"  Average Coating: {avg_coating:.2f} mm\n"
                            analysis += f"  Average Corrosion: {avg_corrosion:.2f} mm\n"
                            analysis += f"  Parts: {', '.join([part_names[i] for i in set(cluster_parts)])}\n\n"
                    
                    # PCA for dimensionality reduction
                    if len(ml_data) > 5:
                        pca = PCA(n_components=2)
                        pca_result = pca.fit_transform(ml_data_scaled)
                        
                        analysis += f"=== PRINCIPAL COMPONENT ANALYSIS ===\n"
                        analysis += f"Explained variance ratio: {pca.explained_variance_ratio_[0]:.3f}, {pca.explained_variance_ratio_[1]:.3f}\n"
                        analysis += f"Total explained variance: {sum(pca.explained_variance_ratio_):.3f}\n\n"
                        
                        # Find outliers
                        outlier_threshold = 2.0
                        outliers = []
                        for i, point in enumerate(pca_result):
                            if abs(point[0]) > outlier_threshold or abs(point[1]) > outlier_threshold:
                                outliers.append(valid_indices[i])
                        
                        if outliers:
                            analysis += f"Outliers detected: {', '.join([part_names[i] for i in set(outliers)])}\n"
                            analysis += "These parts may require special attention.\n\n"
                
                else:
                    analysis += "Insufficient data for machine learning analysis.\n"
                    analysis += "Need at least 4 data points with thickness, coating, and corrosion measurements.\n"
                    
            except ImportError:
                analysis += "⚠️ Scikit-learn not available. Install with: pip install scikit-learn\n"
                analysis += "Falling back to basic statistical analysis...\n\n"
                
                # Basic analysis as fallback
                if all_thickness:
                    analysis += f"Thickness Statistics:\n"
                    analysis += f"  Mean: {np.mean(all_thickness):.2f} mm\n"
                    analysis += f"  Std: {np.std(all_thickness):.2f} mm\n"
                    analysis += f"  Median: {np.median(all_thickness):.2f} mm\n"
                
                if all_coating:
                    analysis += f"Coating Statistics:\n"
                    analysis += f"  Mean: {np.mean(all_coating):.2f} mm\n"
                    analysis += f"  Std: {np.std(all_coating):.2f} mm\n"
                    analysis += f"  Median: {np.median(all_coating):.2f} mm\n"
                
                if all_corrosion:
                    analysis += f"Corrosion Statistics:\n"
                    analysis += f"  Mean: {np.mean(all_corrosion):.2f} mm\n"
                    analysis += f"  Std: {np.std(all_corrosion):.2f} mm\n"
                    analysis += f"  Median: {np.median(all_corrosion):.2f} mm\n"
            
            analysis += "\nAnalysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
        elif analysis_type == "comprehensive":
            analysis = "=== COMPREHENSIVE STATION ANALYSIS ===\n\n"
            analysis += f"Total Parts Analyzed: {len(part_names)}\n\n"
            
            # Part-by-part analysis
            for i, record in enumerate(all_records):
                part_name = part_names[i]
                analysis += f"=== PART: {part_name} ===\n"
                
                # Basic info
                analysis += f"Date/Time: {record['meta'].get('datetime', 'Unknown')}\n"
                diameter = record["meta"].get("diameter")
                if diameter:
                    analysis += f"Diameter: {diameter} mm\n"
                
                # Extract data
                thickness_data = []
                coating_data = []
                corrosion_data = []
                
                if "THme (mm)" in record["headers"]:
                    idx = record["headers"].index("THme (mm)")
                    thickness_data = [row[idx] for row in record["data"]]
                    
                if "COth (mm)" in record["headers"]:
                    idx = record["headers"].index("COth (mm)")
                    coating_data = [row[idx] for row in record["data"]]
                    
                if "CR (mm)" in record["headers"]:
                    idx = record["headers"].index("CR (mm)")
                    corrosion_data = [row[idx] for row in record["data"]]
                
                # Thickness analysis
                if thickness_data:
                    analysis += "\n--- Thickness Analysis ---\n"
                    analysis += f"Measurements: {len(thickness_data)}\n"
                    analysis += f"Minimum: {min(thickness_data):.2f} mm\n"
                    analysis += f"Maximum: {max(thickness_data):.2f} mm\n"
                    analysis += f"Average: {sum(thickness_data)/len(thickness_data):.2f} mm\n"
                    analysis += f"Standard Deviation: {np.std(thickness_data):.2f} mm\n"
                    
                    # Thickness variation
                    avg_thickness = sum(thickness_data) / len(thickness_data) if thickness_data else 0
                    thickness_variation = (max(thickness_data) - min(thickness_data)) / avg_thickness if avg_thickness else 0
                    analysis += f"Thickness Variation: {thickness_variation*100:.1f}%\n"
                
                # Coating analysis
                if coating_data:
                    analysis += "\n--- Coating Analysis ---\n"
                    analysis += f"Measurements: {len(coating_data)}\n"
                    analysis += f"Minimum: {min(coating_data):.2f} mm\n"
                    analysis += f"Maximum: {max(coating_data):.2f} mm\n"
                    analysis += f"Average: {sum(coating_data)/len(coating_data):.2f} mm\n"
                    analysis += f"Standard Deviation: {np.std(coating_data):.2f} mm\n"
                
                # Corrosion analysis
                if corrosion_data:
                    analysis += "\n--- Corrosion Analysis ---\n"
                    analysis += f"Measurements: {len(corrosion_data)}\n"
                    analysis += f"Minimum: {min(corrosion_data):.2f} mm\n"
                    analysis += f"Maximum: {max(corrosion_data):.2f} mm\n"
                    analysis += f"Average: {sum(corrosion_data)/len(corrosion_data):.2f} mm\n"
                    analysis += f"Standard Deviation: {np.std(corrosion_data):.2f} mm\n"
                    
                    dangerous = sum(1 for cr in corrosion_data if cr > 1.0)
                    analysis += f"Dangerous Rates (>1.0 mm): {dangerous} ({dangerous/len(corrosion_data)*100:.1f}%)\n"
                    
                    # Corrosion hotspots
                    if dangerous > 0:
                        hotspots = [i+1 for i, cr in enumerate(corrosion_data) if cr > 1.0]
                        analysis += f"Corrosion Hotspots at Points: {', '.join(map(str, hotspots))}\n"
                
                # Thickness vs Coating comparison
                if thickness_data and coating_data and len(thickness_data) == len(coating_data):
                    analysis += "\n--- Thickness vs Coating ---\n"
                    
                    # Calculate ratios
                    ratios = [t/c if c > 0 else 0 for t, c in zip(thickness_data, coating_data)]
                    analysis += f"Average Thickness/Coating Ratio: {sum(ratios)/len(ratios):.2f}\n"
                    
                    # Find points with unusual ratios
                    unusual_points = [i+1 for i, r in enumerate(ratios) if r < 0.5 or r > 2.0]
                    if unusual_points:
                        analysis += f"Points with Unusual Ratios: {', '.join(map(str, unusual_points))}\n"
                
                # Notes
                notes = record["meta"].get("notes")
                if notes:
                    analysis += f"\n--- Notes ---\n{notes}\n"
                
                analysis += "\n"
            
            # Overall station summary
            analysis += "=== OVERALL STATION SUMMARY ===\n"
            
            if all_diameters:
                analysis += f"Diameter Range: {min(all_diameters):.2f} - {max(all_diameters):.2f} mm\n"
                
            if all_thickness:
                analysis += f"Overall Thickness Range: {min(all_thickness):.2f} - {max(all_thickness):.2f} mm\n"
                
            if all_coating:
                analysis += f"Overall Coating Range: {min(all_coating):.2f} - {max(all_coating):.2f} mm\n"
                
            if all_corrosion:
                dangerous = sum(1 for cr in all_corrosion if cr > 1.0)
                analysis += f"Overall Dangerous Corrosion Rates: {dangerous} out of {len(all_corrosion)} measurements ({dangerous/len(all_corrosion)*100:.1f}%)\n"
                
                # Most critical part
                max_avg_corrosion = 0
                critical_part = ""
                
                for i, record in enumerate(all_records):
                    if "CR (mm)" in record["headers"]:
                        idx = record["headers"].index("CR (mm)")
                        corrosion_data = [row[idx] for row in record["data"]]
                        if corrosion_data:
                            avg_corrosion = sum(corrosion_data) / len(corrosion_data)
                            if avg_corrosion > max_avg_corrosion:
                                max_avg_corrosion = avg_corrosion
                                critical_part = part_names[i]
                
                if critical_part:
                    analysis += f"Most Critical Part: {critical_part} (Avg Corrosion: {max_avg_corrosion:.2f} mm)\n"
            
            analysis += "\nAnalysis completed on: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Display analysis
        self.analysis_text.insert("1.0", analysis)
        
        # Enable export button
        self.export_analysis_btn.configure(state="normal")
        
    def export_analysis(self):
        analysis_text = self.analysis_text.get("1.0", "end")
        
        if not analysis_text.strip():
            messagebox.showwarning("No Analysis", "No analysis to export.")
            return
            
        # Ask for save location
        path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=f"station_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )
        
        if path:
            with open(path, "w", encoding="utf-8") as f:
                f.write(analysis_text)
            messagebox.showinfo("Export", f"Analysis exported to:\n{path}")
            
    # ---------- Arrow key navigation ----------
    def setup_arrow_navigation(self):
        # Get all entry widgets
        self.entries = [
            self.part_entry,
            self.dia_entry,
            self.coth_entry,
            self.thme_entry,
            self.old_entry
        ]
        
        # Bind arrow keys for entries
        for i, entry in enumerate(self.entries):
            entry.bind("<Up>", lambda e, idx=i: self.move_focus(idx, -1))
            entry.bind("<Down>", lambda e, idx=i: self.move_focus(idx, 1))
            
            # For old_entry, handle focus events
            if entry == self.old_entry:
                entry.bind("<FocusIn>", lambda e: self.handle_old_entry_focus(e, True))
                entry.bind("<FocusOut>", lambda e: self.handle_old_entry_focus(e, False))
        
        # Bind arrow keys for the old thickness checkbox
        self.old_check_box.bind("<Down>", self.handle_old_checkbox_down)
        
    def move_focus(self, current_idx, direction):
        new_idx = current_idx + direction
        if 0 <= new_idx < len(self.entries):
            self.entries[new_idx].focus_set()
            
    def handle_old_entry_focus(self, event, is_focus_in):
        if is_focus_in:
            self.old_check.set(True)
            self.old_entry.configure(state="normal")
        else:
            if not self.old_vals.get().strip():
                self.old_check.set(False)
                self.old_entry.configure(state="disabled")
    
    def handle_old_checkbox_down(self, event):
        """Handle down arrow when focus is on Old Thickness checkbox"""
        if self.old_check.get():  # If checkbox is checked
            self.old_entry.focus_set()  # Move focus to Old Thickness input box
        else:
            # If checkbox is not checked, move to next field
            self.move_focus(4, 1)  # old_entry is at index 4
    
    def check_old_entry(self):
        if not self.old_vals.get().strip():
            self.old_check.set(False)
            self.old_entry.configure(state="disabled")
            
# ---------- run ----------
if __name__ == "__main__":
    app = App()
    app.mainloop()
